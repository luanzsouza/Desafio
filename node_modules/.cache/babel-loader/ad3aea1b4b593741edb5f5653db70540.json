{"ast":null,"code":"/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model'),\n    _ = require('underscore');\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\n\n\nfunction Cursor(db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n\n  if (execFn) {\n    this.execFn = execFn;\n  }\n}\n/**\n * Set a limit to the number of results\n */\n\n\nCursor.prototype.limit = function (limit) {\n  this._limit = limit;\n  return this;\n};\n/**\n * Skip a the number of results\n */\n\n\nCursor.prototype.skip = function (skip) {\n  this._skip = skip;\n  return this;\n};\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\n\n\nCursor.prototype.sort = function (sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\n\n\nCursor.prototype.projection = function (projection) {\n  this._projection = projection;\n  return this;\n};\n/**\n * Apply the projection\n */\n\n\nCursor.prototype.project = function (candidates) {\n  var res = [],\n      self = this,\n      keepId,\n      action,\n      keys;\n\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id'); // Check for consistency\n\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) {\n      throw new Error(\"Can't both keep and omit fields except for _id\");\n    }\n\n    action = self._projection[k];\n  }); // Do the actual projection\n\n  candidates.forEach(function (candidate) {\n    var toPush;\n\n    if (action === 1) {\n      // pick-type projection\n      toPush = {\n        $set: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n\n        if (toPush.$set[k] === undefined) {\n          delete toPush.$set[k];\n        }\n      });\n      toPush = model.modify({}, toPush);\n    } else {\n      // omit-type projection\n      toPush = {\n        $unset: {}\n      };\n      keys.forEach(function (k) {\n        toPush.$unset[k] = true;\n      });\n      toPush = model.modify(candidate, toPush);\n    }\n\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n\n    res.push(toPush);\n  });\n  return res;\n};\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\n\n\nCursor.prototype._exec = function (_callback) {\n  var res = [],\n      added = 0,\n      skipped = 0,\n      self = this,\n      error = null,\n      i,\n      keys,\n      key;\n\n  function callback(error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n\n              if (self._limit && self._limit <= added) {\n                break;\n              }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    } // Apply all sorts\n\n\n    if (self._sort) {\n      keys = Object.keys(self._sort); // Sorting\n\n      var criteria = [];\n\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({\n          key: key,\n          direction: self._sort[key]\n        });\n      }\n\n      res.sort(function (a, b) {\n        var criterion, compare, i;\n\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n\n        return 0;\n      }); // Applying limit and skip\n\n      var limit = self._limit || res.length,\n          skip = self._skip || 0;\n      res = res.slice(skip, skip + limit);\n    } // Apply projection\n\n\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n\n    return callback(error, res);\n  });\n};\n\nCursor.prototype.exec = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this._exec,\n    arguments: arguments\n  });\n}; // Interface\n\n\nmodule.exports = Cursor;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Ãrea de Trabalho/Desafio MM/node_modules/nedb/lib/cursor.js"],"names":["model","require","_","Cursor","db","query","execFn","prototype","limit","_limit","skip","_skip","sort","sortQuery","_sort","projection","_projection","project","candidates","res","self","keepId","action","keys","undefined","Object","length","_id","omit","forEach","k","Error","candidate","toPush","$set","getDotValue","modify","$unset","push","_exec","_callback","added","skipped","error","i","key","callback","getCandidates","err","match","criteria","direction","a","b","criterion","compare","compareThings","compareStrings","slice","e","exec","executor","this","fn","arguments","module","exports"],"mappings":"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","sourcesContent":["/**\n * Manage access to data, be it to find, update or remove it\n */\nvar model = require('./model')\n  , _ = require('underscore')\n  ;\n\n\n\n/**\n * Create a new cursor for this collection\n * @param {Datastore} db - The datastore this cursor is bound to\n * @param {Query} query - The query this cursor will operate on\n * @param {Function} execFn - Handler to be executed after cursor has found the results and before the callback passed to find/findOne/update/remove\n */\nfunction Cursor (db, query, execFn) {\n  this.db = db;\n  this.query = query || {};\n  if (execFn) { this.execFn = execFn; }\n}\n\n\n/**\n * Set a limit to the number of results\n */\nCursor.prototype.limit = function(limit) {\n  this._limit = limit;\n  return this;\n};\n\n\n/**\n * Skip a the number of results\n */\nCursor.prototype.skip = function(skip) {\n  this._skip = skip;\n  return this;\n};\n\n\n/**\n * Sort results of the query\n * @param {SortQuery} sortQuery - SortQuery is { field: order }, field can use the dot-notation, order is 1 for ascending and -1 for descending\n */\nCursor.prototype.sort = function(sortQuery) {\n  this._sort = sortQuery;\n  return this;\n};\n\n\n/**\n * Add the use of a projection\n * @param {Object} projection - MongoDB-style projection. {} means take all fields. Then it's { key1: 1, key2: 1 } to take only key1 and key2\n *                              { key1: 0, key2: 0 } to omit only key1 and key2. Except _id, you can't mix takes and omits\n */\nCursor.prototype.projection = function(projection) {\n  this._projection = projection;\n  return this;\n};\n\n\n/**\n * Apply the projection\n */\nCursor.prototype.project = function (candidates) {\n  var res = [], self = this\n    , keepId, action, keys\n    ;\n\n  if (this._projection === undefined || Object.keys(this._projection).length === 0) {\n    return candidates;\n  }\n\n  keepId = this._projection._id === 0 ? false : true;\n  this._projection = _.omit(this._projection, '_id');\n\n  // Check for consistency\n  keys = Object.keys(this._projection);\n  keys.forEach(function (k) {\n    if (action !== undefined && self._projection[k] !== action) { throw new Error(\"Can't both keep and omit fields except for _id\"); }\n    action = self._projection[k];\n  });\n\n  // Do the actual projection\n  candidates.forEach(function (candidate) {\n    var toPush;\n    if (action === 1) {   // pick-type projection\n      toPush = { $set: {} };\n      keys.forEach(function (k) {\n        toPush.$set[k] = model.getDotValue(candidate, k);\n        if (toPush.$set[k] === undefined) { delete toPush.$set[k]; }\n      });\n      toPush = model.modify({}, toPush);\n    } else {   // omit-type projection\n      toPush = { $unset: {} };\n      keys.forEach(function (k) { toPush.$unset[k] = true });\n      toPush = model.modify(candidate, toPush);\n    }\n    if (keepId) {\n      toPush._id = candidate._id;\n    } else {\n      delete toPush._id;\n    }\n    res.push(toPush);\n  });\n\n  return res;\n};\n\n\n/**\n * Get all matching elements\n * Will return pointers to matched elements (shallow copies), returning full copies is the role of find or findOne\n * This is an internal function, use exec which uses the executor\n *\n * @param {Function} callback - Signature: err, results\n */\nCursor.prototype._exec = function(_callback) {\n  var res = [], added = 0, skipped = 0, self = this\n    , error = null\n    , i, keys, key\n    ;\n\n  function callback (error, res) {\n    if (self.execFn) {\n      return self.execFn(error, res, _callback);\n    } else {\n      return _callback(error, res);\n    }\n  }\n\n  this.db.getCandidates(this.query, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      for (i = 0; i < candidates.length; i += 1) {\n        if (model.match(candidates[i], self.query)) {\n          // If a sort is defined, wait for the results to be sorted before applying limit and skip\n          if (!self._sort) {\n            if (self._skip && self._skip > skipped) {\n              skipped += 1;\n            } else {\n              res.push(candidates[i]);\n              added += 1;\n              if (self._limit && self._limit <= added) { break; }\n            }\n          } else {\n            res.push(candidates[i]);\n          }\n        }\n      }\n    } catch (err) {\n      return callback(err);\n    }\n\n    // Apply all sorts\n    if (self._sort) {\n      keys = Object.keys(self._sort);\n\n      // Sorting\n      var criteria = [];\n      for (i = 0; i < keys.length; i++) {\n        key = keys[i];\n        criteria.push({ key: key, direction: self._sort[key] });\n      }\n      res.sort(function(a, b) {\n        var criterion, compare, i;\n        for (i = 0; i < criteria.length; i++) {\n          criterion = criteria[i];\n          compare = criterion.direction * model.compareThings(model.getDotValue(a, criterion.key), model.getDotValue(b, criterion.key), self.db.compareStrings);\n          if (compare !== 0) {\n            return compare;\n          }\n        }\n        return 0;\n      });\n\n      // Applying limit and skip\n      var limit = self._limit || res.length\n        , skip = self._skip || 0;\n\n      res = res.slice(skip, skip + limit);\n    }\n\n    // Apply projection\n    try {\n      res = self.project(res);\n    } catch (e) {\n      error = e;\n      res = undefined;\n    }\n\n    return callback(error, res);\n  });\n};\n\nCursor.prototype.exec = function () {\n  this.db.executor.push({ this: this, fn: this._exec, arguments: arguments });\n};\n\n\n\n// Interface\nmodule.exports = Cursor;\n"]},"metadata":{},"sourceType":"script"}