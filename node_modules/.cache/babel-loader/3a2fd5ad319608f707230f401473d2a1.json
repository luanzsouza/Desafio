{"ast":null,"code":"var BinarySearchTree = require('binary-search-tree').AVLTree,\n    model = require('./model'),\n    _ = require('underscore'),\n    util = require('util');\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\n\n\nfunction checkValueEquality(a, b) {\n  return a === b;\n}\n/**\n * Type-aware projection\n */\n\n\nfunction projectForUnique(elt) {\n  if (elt === null) {\n    return '$null';\n  }\n\n  if (typeof elt === 'string') {\n    return '$string' + elt;\n  }\n\n  if (typeof elt === 'boolean') {\n    return '$boolean' + elt;\n  }\n\n  if (typeof elt === 'number') {\n    return '$number' + elt;\n  }\n\n  if (util.isArray(elt)) {\n    return '$date' + elt.getTime();\n  }\n\n  return elt; // Arrays and objects, will check for pointer equality\n}\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\n\n\nfunction Index(options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n  this.treeOptions = {\n    unique: this.unique,\n    compareKeys: model.compareThings,\n    checkValueEquality: checkValueEquality\n  };\n  this.reset(); // No data in the beginning\n}\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\n\n\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) {\n    this.insert(newData);\n  }\n};\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\n\n\nIndex.prototype.insert = function (doc) {\n  var key,\n      self = this,\n      keys,\n      i,\n      failingI,\n      error;\n\n  if (util.isArray(doc)) {\n    this.insertMultipleDocs(doc);\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName); // We don't index documents that don't contain the field if the index is sparse\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\n\n\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\n\n\nIndex.prototype.remove = function (doc) {\n  var key,\n      self = this;\n\n  if (util.isArray(doc)) {\n    doc.forEach(function (d) {\n      self.remove(d);\n    });\n    return;\n  }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) {\n    return;\n  }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\n\n\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) {\n    this.updateMultipleDocs(oldDoc);\n    return;\n  }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\n\n\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  } // If an error was raised, roll back changes in the inverse order\n\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Revert an update\n */\n\n\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({\n        oldDoc: pair.newDoc,\n        newDoc: pair.oldDoc\n      });\n    });\n    this.update(revert);\n  }\n};\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {},\n        res = [];\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n    return res;\n  }\n};\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\n\n\nIndex.prototype.getAll = function () {\n  var res = [];\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n  return res;\n}; // Interface\n\n\nmodule.exports = Index;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/nedb/lib/indexes.js"],"names":["BinarySearchTree","require","AVLTree","model","_","util","checkValueEquality","a","b","projectForUnique","elt","isArray","getTime","Index","options","fieldName","unique","sparse","treeOptions","compareKeys","compareThings","reset","prototype","newData","tree","insert","doc","key","self","keys","i","failingI","error","insertMultipleDocs","getDotValue","undefined","uniq","length","e","delete","docs","remove","forEach","d","_key","update","oldDoc","newDoc","updateMultipleDocs","pairs","revertUpdate","revert","pair","push","getMatching","value","search","_res","res","v","_id","Object","getBetweenBounds","query","betweenBounds","getAll","executeOnEveryNode","node","data","module","exports"],"mappings":"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","sourcesContent":["var BinarySearchTree = require('binary-search-tree').AVLTree\n  , model = require('./model')\n  , _ = require('underscore')\n  , util = require('util')\n  ;\n\n/**\n * Two indexed pointers are equal iif they point to the same place\n */\nfunction checkValueEquality (a, b) {\n  return a === b;\n}\n\n/**\n * Type-aware projection\n */\nfunction projectForUnique (elt) {\n  if (elt === null) { return '$null'; }\n  if (typeof elt === 'string') { return '$string' + elt; }\n  if (typeof elt === 'boolean') { return '$boolean' + elt; }\n  if (typeof elt === 'number') { return '$number' + elt; }\n  if (util.isArray(elt)) { return '$date' + elt.getTime(); }\n\n  return elt;   // Arrays and objects, will check for pointer equality\n}\n\n\n/**\n * Create a new index\n * All methods on an index guarantee that either the whole operation was successful and the index changed\n * or the operation was unsuccessful and an error is thrown while the index is unchanged\n * @param {String} options.fieldName On which field should the index apply (can use dot notation to index on sub fields)\n * @param {Boolean} options.unique Optional, enforce a unique constraint (default: false)\n * @param {Boolean} options.sparse Optional, allow a sparse index (we can have documents for which fieldName is undefined) (default: false)\n */\nfunction Index (options) {\n  this.fieldName = options.fieldName;\n  this.unique = options.unique || false;\n  this.sparse = options.sparse || false;\n\n  this.treeOptions = { unique: this.unique, compareKeys: model.compareThings, checkValueEquality: checkValueEquality };\n\n  this.reset();   // No data in the beginning\n}\n\n\n/**\n * Reset an index\n * @param {Document or Array of documents} newData Optional, data to initialize the index with\n *                                                 If an error is thrown during insertion, the index is not modified\n */\nIndex.prototype.reset = function (newData) {\n  this.tree = new BinarySearchTree(this.treeOptions);\n\n  if (newData) { this.insert(newData); }\n};\n\n\n/**\n * Insert a new document in the index\n * If an array is passed, we insert all its elements (if one insertion fails the index is not modified)\n * O(log(n))\n */\nIndex.prototype.insert = function (doc) {\n  var key, self = this\n    , keys, i, failingI, error\n    ;\n\n  if (util.isArray(doc)) { this.insertMultipleDocs(doc); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  // We don't index documents that don't contain the field if the index is sparse\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.insert(key, doc);\n  } else {\n    // If an insert fails due to a unique constraint, roll back all inserts before it\n    keys = _.uniq(key, projectForUnique);\n\n    for (i = 0; i < keys.length; i += 1) {\n      try {\n        this.tree.insert(keys[i], doc);\n      } catch (e) {\n        error = e;\n        failingI = i;\n        break;\n      }\n    }\n\n    if (error) {\n      for (i = 0; i < failingI; i += 1) {\n        this.tree.delete(keys[i], doc);\n      }\n\n      throw error;\n    }\n  }\n};\n\n\n/**\n * Insert an array of documents in the index\n * If a constraint is violated, the changes should be rolled back and an error thrown\n *\n * @API private\n */\nIndex.prototype.insertMultipleDocs = function (docs) {\n  var i, error, failingI;\n\n  for (i = 0; i < docs.length; i += 1) {\n    try {\n      this.insert(docs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(docs[i]);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove a document from the index\n * If an array is passed, we remove all its elements\n * The remove operation is safe with regards to the 'unique' constraint\n * O(log(n))\n */\nIndex.prototype.remove = function (doc) {\n  var key, self = this;\n\n  if (util.isArray(doc)) { doc.forEach(function (d) { self.remove(d); }); return; }\n\n  key = model.getDotValue(doc, this.fieldName);\n\n  if (key === undefined && this.sparse) { return; }\n\n  if (!util.isArray(key)) {\n    this.tree.delete(key, doc);\n  } else {\n    _.uniq(key, projectForUnique).forEach(function (_key) {\n      self.tree.delete(_key, doc);\n    });\n  }\n};\n\n\n/**\n * Update a document in the index\n * If a constraint is violated, changes are rolled back and an error thrown\n * Naive implementation, still in O(log(n))\n */\nIndex.prototype.update = function (oldDoc, newDoc) {\n  if (util.isArray(oldDoc)) { this.updateMultipleDocs(oldDoc); return; }\n\n  this.remove(oldDoc);\n\n  try {\n    this.insert(newDoc);\n  } catch (e) {\n    this.insert(oldDoc);\n    throw e;\n  }\n};\n\n\n/**\n * Update multiple documents in the index\n * If a constraint is violated, the changes need to be rolled back\n * and an error thrown\n * @param {Array of oldDoc, newDoc pairs} pairs\n *\n * @API private\n */\nIndex.prototype.updateMultipleDocs = function (pairs) {\n  var i, failingI, error;\n\n  for (i = 0; i < pairs.length; i += 1) {\n    this.remove(pairs[i].oldDoc);\n  }\n\n  for (i = 0; i < pairs.length; i += 1) {\n    try {\n      this.insert(pairs[i].newDoc);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  // If an error was raised, roll back changes in the inverse order\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.remove(pairs[i].newDoc);\n    }\n\n    for (i = 0; i < pairs.length; i += 1) {\n      this.insert(pairs[i].oldDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Revert an update\n */\nIndex.prototype.revertUpdate = function (oldDoc, newDoc) {\n  var revert = [];\n\n  if (!util.isArray(oldDoc)) {\n    this.update(newDoc, oldDoc);\n  } else {\n    oldDoc.forEach(function (pair) {\n      revert.push({ oldDoc: pair.newDoc, newDoc: pair.oldDoc });\n    });\n    this.update(revert);\n  }\n};\n\n\n/**\n * Get all documents in index whose key match value (if it is a Thing) or one of the elements of value (if it is an array of Things)\n * @param {Thing} value Value to match the key against\n * @return {Array of documents}\n */\nIndex.prototype.getMatching = function (value) {\n  var self = this;\n\n  if (!util.isArray(value)) {\n    return self.tree.search(value);\n  } else {\n    var _res = {}, res = [];\n\n    value.forEach(function (v) {\n      self.getMatching(v).forEach(function (doc) {\n        _res[doc._id] = doc;\n      });\n    });\n\n    Object.keys(_res).forEach(function (_id) {\n      res.push(_res[_id]);\n    });\n\n    return res;\n  }\n};\n\n\n/**\n * Get all documents in index whose key is between bounds are they are defined by query\n * Documents are sorted by key\n * @param {Query} query\n * @return {Array of documents}\n */\nIndex.prototype.getBetweenBounds = function (query) {\n  return this.tree.betweenBounds(query);\n};\n\n\n/**\n * Get all elements in the index\n * @return {Array of documents}\n */\nIndex.prototype.getAll = function () {\n  var res = [];\n\n  this.tree.executeOnEveryNode(function (node) {\n    var i;\n\n    for (i = 0; i < node.data.length; i += 1) {\n      res.push(node.data[i]);\n    }\n  });\n\n  return res;\n};\n\n\n\n\n// Interface\nmodule.exports = Index;\n"]},"metadata":{},"sourceType":"script"}