{"ast":null,"code":"/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst'),\n    customUtils = require('./customUtils'),\n    util = require('util'),\n    _ = require('underscore');\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction AVLTree(options) {\n  this.tree = new _AVLTree(options);\n}\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction _AVLTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n/**\n * Inherit basic functions from the basic binary search tree\n */\n\n\nutil.inherits(_AVLTree, BinarySearchTree);\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\n\nAVLTree._AVLTree = _AVLTree;\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  } // Empty tree\n\n\n  if (this.left && this.left.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.left.key);\n  }\n\n  if (this.right && this.right.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.right.key);\n  }\n\n  if (this.height === undefined) {\n    throw new Error(\"Undefined height for node \" + this.key);\n  }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) {\n    throw new Error(\"Height constraint failed for node \" + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkHeightCorrect();\n  }\n\n  if (this.right) {\n    this.right.checkHeightCorrect();\n  }\n};\n/**\n * Return the balance factor\n */\n\n\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0,\n      rightH = this.right ? this.right.height : 0;\n  return leftH - rightH;\n};\n/**\n * Check that the balance factors are all between -1 and 1\n */\n\n\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) {\n    throw new Error('Tree is unbalanced at node ' + this.key);\n  }\n\n  if (this.left) {\n    this.left.checkBalanceFactors();\n  }\n\n  if (this.right) {\n    this.right.checkBalanceFactors();\n  }\n};\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n\n\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\n\nAVLTree.prototype.checkIsAVLT = function () {\n  this.tree.checkIsAVLT();\n};\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.rightRotation = function () {\n  var q = this,\n      p = this.left,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!p) {\n    return this;\n  } // No change\n\n\n  b = p.right; // Alter tree structure\n\n  if (q.parent) {\n    p.parent = q.parent;\n\n    if (q.parent.left === q) {\n      q.parent.left = p;\n    } else {\n      q.parent.right = p;\n    }\n  } else {\n    p.parent = null;\n  }\n\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n\n  if (b) {\n    b.parent = q;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n  return p;\n};\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n\n\n_AVLTree.prototype.leftRotation = function () {\n  var p = this,\n      q = this.right,\n      b,\n      ah,\n      bh,\n      ch;\n\n  if (!q) {\n    return this;\n  } // No change\n\n\n  b = q.left; // Alter tree structure\n\n  if (p.parent) {\n    q.parent = p.parent;\n\n    if (p.parent.left === p) {\n      p.parent.left = q;\n    } else {\n      p.parent.right = q;\n    }\n  } else {\n    q.parent = null;\n  }\n\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n\n  if (b) {\n    b.parent = p;\n  } // Update heights\n\n\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n  return q;\n};\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) {\n    return this;\n  } // Right is not too small, don't change\n\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n\n\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) {\n    return this;\n  } // Left is not too small, don't change\n\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n\n\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this,\n      rotated,\n      i;\n\n  if (!this.hasOwnProperty('key')) {\n    delete this.height;\n    return this;\n  } // Empty tree\n  // Rebalance the tree and update all heights\n\n\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n\n      if (i === 0) {\n        newRoot = rotated;\n      }\n    }\n  }\n\n  return newRoot;\n};\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n\n\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = [],\n      currentNode = this; // Empty tree, insert as root\n\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  } // Insert new leaf at the right place\n\n\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({\n          key: key,\n          value: value\n        }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n}; // Insert in the internal tree, update the pointer to the root if needed\n\n\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this,\n      currentNode = this,\n      deletePath = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return this;\n  } // Empty tree\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n\n\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) {\n      break;\n    }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this; // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this; // Key not found, no modification\n      }\n    }\n  } // Delete only a value (no tree modification)\n\n\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    currentNode.data = newData;\n    return this;\n  } // Delete a whole node\n  // Leaf\n\n\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {\n      // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with only one child\n\n\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {\n      // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith; // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  } // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n\n\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left; // Special case: the in-order predecessor is right below the node to delete\n\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n\n    if (replaceWith.left) {\n      replaceWith.left.parent = currentNode;\n    }\n\n    return this.rebalanceAlongPath(deletePath);\n  } // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n\n\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n  replaceWith.parent.right = replaceWith.left;\n\n  if (replaceWith.left) {\n    replaceWith.left.parent = replaceWith.parent;\n  }\n\n  return this.rebalanceAlongPath(deletePath);\n}; // Delete a value\n\n\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value); // If newTree is undefined, that means its structure was not modified\n\n  if (newTree) {\n    this.tree = newTree;\n  }\n};\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n\n\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n}); // Interface\n\nmodule.exports = AVLTree;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/binary-search-tree/lib/avltree.js"],"names":["BinarySearchTree","require","customUtils","util","_","AVLTree","options","tree","_AVLTree","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","inherits","prototype","checkHeightCorrect","leftH","rightH","height","Error","Math","max","balanceFactor","checkBalanceFactors","abs","checkIsAVLT","super_","checkIsBST","call","rightRotation","q","p","b","ah","bh","ch","leftRotation","rightTooSmall","leftTooSmall","rebalanceAlongPath","path","newRoot","rotated","i","length","insert","insertPath","currentNode","push","err","errorType","createLeftChild","createRightChild","newTree","delete","newData","replaceWith","self","deletePath","forEach","d","fn","apply","arguments","module","exports"],"mappings":"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","sourcesContent":["/**\n * Self-balancing binary search tree using the AVL implementation\n */\nvar BinarySearchTree = require('./bst')\n  , customUtils = require('./customUtils')\n  , util = require('util')\n  , _ = require('underscore')\n  ;\n\n\n/**\n * Constructor\n * We can't use a direct pointer to the root node (as in the simple binary search tree)\n * as the root will change during tree rotations\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction AVLTree (options) {\n  this.tree = new _AVLTree(options);\n}\n\n\n/**\n * Constructor of the internal AVLTree\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction _AVLTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n/**\n * Inherit basic functions from the basic binary search tree\n */\nutil.inherits(_AVLTree, BinarySearchTree);\n\n/**\n * Keep a pointer to the internal tree constructor for testing purposes\n */\nAVLTree._AVLTree = _AVLTree;\n\n\n/**\n * Check the recorded height is correct for every node\n * Throws if one height doesn't match\n */\n_AVLTree.prototype.checkHeightCorrect = function () {\n  var leftH, rightH;\n\n  if (!this.hasOwnProperty('key')) { return; }   // Empty tree\n\n  if (this.left && this.left.height === undefined) { throw new Error(\"Undefined height for node \" + this.left.key); }\n  if (this.right && this.right.height === undefined) { throw new Error(\"Undefined height for node \" + this.right.key); }\n  if (this.height === undefined) { throw new Error(\"Undefined height for node \" + this.key); }\n\n  leftH = this.left ? this.left.height : 0;\n  rightH = this.right ? this.right.height : 0;\n\n  if (this.height !== 1 + Math.max(leftH, rightH)) { throw new Error(\"Height constraint failed for node \" + this.key); }\n  if (this.left) { this.left.checkHeightCorrect(); }\n  if (this.right) { this.right.checkHeightCorrect(); }\n};\n\n\n/**\n * Return the balance factor\n */\n_AVLTree.prototype.balanceFactor = function () {\n  var leftH = this.left ? this.left.height : 0\n    , rightH = this.right ? this.right.height : 0\n    ;\n  return leftH - rightH;\n};\n\n\n/**\n * Check that the balance factors are all between -1 and 1\n */\n_AVLTree.prototype.checkBalanceFactors = function () {\n  if (Math.abs(this.balanceFactor()) > 1) { throw new Error('Tree is unbalanced at node ' + this.key); }\n\n  if (this.left) { this.left.checkBalanceFactors(); }\n  if (this.right) { this.right.checkBalanceFactors(); }\n};\n\n\n/**\n * When checking if the BST conditions are met, also check that the heights are correct\n * and the tree is balanced\n */\n_AVLTree.prototype.checkIsAVLT = function () {\n  _AVLTree.super_.prototype.checkIsBST.call(this);\n  this.checkHeightCorrect();\n  this.checkBalanceFactors();\n};\nAVLTree.prototype.checkIsAVLT = function () { this.tree.checkIsAVLT(); };\n\n\n/**\n * Perform a right rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.rightRotation = function () {\n  var q = this\n    , p = this.left\n    , b\n    , ah, bh, ch;\n\n  if (!p) { return this; }   // No change\n\n  b = p.right;\n\n  // Alter tree structure\n  if (q.parent) {\n    p.parent = q.parent;\n    if (q.parent.left === q) { q.parent.left = p; } else { q.parent.right = p; }\n  } else {\n    p.parent = null;\n  }\n  p.right = q;\n  q.parent = p;\n  q.left = b;\n  if (b) { b.parent = q; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  q.height = Math.max(bh, ch) + 1;\n  p.height = Math.max(ah, q.height) + 1;\n\n  return p;\n};\n\n\n/**\n * Perform a left rotation of the tree if possible\n * and return the root of the resulting tree\n * The resulting tree's nodes' heights are also updated\n */\n_AVLTree.prototype.leftRotation = function () {\n  var p = this\n    , q = this.right\n    , b\n    , ah, bh, ch;\n\n  if (!q) { return this; }   // No change\n\n  b = q.left;\n\n  // Alter tree structure\n  if (p.parent) {\n    q.parent = p.parent;\n    if (p.parent.left === p) { p.parent.left = q; } else { p.parent.right = q; }\n  } else {\n    q.parent = null;\n  }\n  q.left = p;\n  p.parent = q;\n  p.right = b;\n  if (b) { b.parent = p; }\n\n  // Update heights\n  ah = p.left ? p.left.height : 0;\n  bh = b ? b.height : 0;\n  ch = q.right ? q.right.height : 0;\n  p.height = Math.max(ah, bh) + 1;\n  q.height = Math.max(ch, p.height) + 1;\n\n  return q;\n};\n\n\n/**\n * Modify the tree if its right subtree is too small compared to the left\n * Return the new root if any\n */\n_AVLTree.prototype.rightTooSmall = function () {\n  if (this.balanceFactor() <= 1) { return this; }   // Right is not too small, don't change\n\n  if (this.left.balanceFactor() < 0) {\n    this.left.leftRotation();\n  }\n\n  return this.rightRotation();\n};\n\n\n/**\n * Modify the tree if its left subtree is too small compared to the right\n * Return the new root if any\n */\n_AVLTree.prototype.leftTooSmall = function () {\n  if (this.balanceFactor() >= -1) { return this; }   // Left is not too small, don't change\n\n  if (this.right.balanceFactor() > 0) {\n    this.right.rightRotation();\n  }\n\n  return this.leftRotation();\n};\n\n\n/**\n * Rebalance the tree along the given path. The path is given reversed (as he was calculated\n * in the insert and delete functions).\n * Returns the new root of the tree\n * Of course, the first element of the path must be the root of the tree\n */\n_AVLTree.prototype.rebalanceAlongPath = function (path) {\n  var newRoot = this\n    , rotated\n    , i;\n\n  if (!this.hasOwnProperty('key')) { delete this.height; return this; }   // Empty tree\n\n  // Rebalance the tree and update all heights\n  for (i = path.length - 1; i >= 0; i -= 1) {\n    path[i].height = 1 + Math.max(path[i].left ? path[i].left.height : 0, path[i].right ? path[i].right.height : 0);\n\n    if (path[i].balanceFactor() > 1) {\n      rotated = path[i].rightTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n\n    if (path[i].balanceFactor() < -1) {\n      rotated = path[i].leftTooSmall();\n      if (i === 0) { newRoot = rotated; }\n    }\n  }\n\n  return newRoot;\n};\n\n\n/**\n * Insert a key, value pair in the tree while maintaining the AVL tree height constraint\n * Return a pointer to the root node, which may have changed\n */\n_AVLTree.prototype.insert = function (key, value) {\n  var insertPath = []\n    , currentNode = this\n    ;\n\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    this.height = 1;\n    return this;\n  }\n\n  // Insert new leaf at the right place\n  while (true) {\n    // Same key: no change in the tree structure\n    if (currentNode.compareKeys(currentNode.key, key) === 0) {\n      if (currentNode.unique) {\n        var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n        err.key = key;\n        err.errorType = 'uniqueViolated';\n        throw err;\n      } else {\n        currentNode.data.push(value);\n      }\n      return this;\n    }\n\n    insertPath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (!currentNode.left) {\n        insertPath.push(currentNode.createLeftChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        insertPath.push(currentNode.createRightChild({ key: key, value: value }));\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n\n  return this.rebalanceAlongPath(insertPath);\n};\n\n// Insert in the internal tree, update the pointer to the root if needed\nAVLTree.prototype.insert = function (key, value) {\n  var newTree = this.tree.insert(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Delete a key or just a value and return the new root of the tree\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n_AVLTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    , currentNode = this\n    , deletePath = []\n    ;\n\n  if (!this.hasOwnProperty('key')) { return this; }   // Empty tree\n\n  // Either no match is found and the function will return from within the loop\n  // Or a match is found and deletePath will contain the path from the root to the node to delete after the loop\n  while (true) {\n    if (currentNode.compareKeys(key, currentNode.key) === 0) { break; }\n\n    deletePath.push(currentNode);\n\n    if (currentNode.compareKeys(key, currentNode.key) < 0) {\n      if (currentNode.left) {\n        currentNode = currentNode.left;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    } else {\n      // currentNode.compareKeys(key, currentNode.key) is > 0\n      if (currentNode.right) {\n        currentNode = currentNode.right;\n      } else {\n        return this;   // Key not found, no modification\n      }\n    }\n  }\n\n  // Delete only a value (no tree modification)\n  if (currentNode.data.length > 1 && value) {\n    currentNode.data.forEach(function (d) {\n      if (!currentNode.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    currentNode.data = newData;\n    return this;\n  }\n\n  // Delete a whole node\n\n  // Leaf\n  if (!currentNode.left && !currentNode.right) {\n    if (currentNode === this) {   // This leaf is also the root\n      delete currentNode.key;\n      currentNode.data = [];\n      delete currentNode.height;\n      return this;\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = null;\n      } else {\n        currentNode.parent.right = null;\n      }\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with only one child\n  if (!currentNode.left || !currentNode.right) {\n    replaceWith = currentNode.left ? currentNode.left : currentNode.right;\n\n    if (currentNode === this) {   // This node is also the root\n      replaceWith.parent = null;\n      return replaceWith;   // height of replaceWith is necessarily 1 because the tree was balanced before deletion\n    } else {\n      if (currentNode.parent.left === currentNode) {\n        currentNode.parent.left = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      } else {\n        currentNode.parent.right = replaceWith;\n        replaceWith.parent = currentNode.parent;\n      }\n\n      return this.rebalanceAlongPath(deletePath);\n    }\n  }\n\n\n  // Node with two children\n  // Use the in-order predecessor (no need to randomize since we actively rebalance)\n  deletePath.push(currentNode);\n  replaceWith = currentNode.left;\n\n  // Special case: the in-order predecessor is right below the node to delete\n  if (!replaceWith.right) {\n    currentNode.key = replaceWith.key;\n    currentNode.data = replaceWith.data;\n    currentNode.left = replaceWith.left;\n    if (replaceWith.left) { replaceWith.left.parent = currentNode; }\n    return this.rebalanceAlongPath(deletePath);\n  }\n\n  // After this loop, replaceWith is the right-most leaf in the left subtree\n  // and deletePath the path from the root (inclusive) to replaceWith (exclusive)\n  while (true) {\n    if (replaceWith.right) {\n      deletePath.push(replaceWith);\n      replaceWith = replaceWith.right;\n    } else {\n      break;\n    }\n  }\n\n  currentNode.key = replaceWith.key;\n  currentNode.data = replaceWith.data;\n\n  replaceWith.parent.right = replaceWith.left;\n  if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n\n  return this.rebalanceAlongPath(deletePath);\n};\n\n// Delete a value\nAVLTree.prototype.delete = function (key, value) {\n  var newTree = this.tree.delete(key, value);\n\n  // If newTree is undefined, that means its structure was not modified\n  if (newTree) { this.tree = newTree; }\n};\n\n\n/**\n * Other functions we want to use on an AVLTree as if it were the internal _AVLTree\n */\n['getNumberOfKeys', 'search', 'betweenBounds', 'prettyPrint', 'executeOnEveryNode'].forEach(function (fn) {\n  AVLTree.prototype[fn] = function () {\n    return this.tree[fn].apply(this.tree, arguments);\n  };\n});\n\n\n// Interface\nmodule.exports = AVLTree;\n"]},"metadata":{},"sourceType":"script"}