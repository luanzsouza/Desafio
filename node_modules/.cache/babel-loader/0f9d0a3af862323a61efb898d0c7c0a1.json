{"ast":null,"code":"/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\nvar storage = require('./storage'),\n    path = require('path'),\n    model = require('./model'),\n    async = require('async'),\n    customUtils = require('./customUtils'),\n    Index = require('./indexes');\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\n\n\nfunction Persistence(options) {\n  var i, j, randomString;\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  } // After serialization and before deserialization hooks with some basic sanity checks\n\n\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  this.afterSerialization = options.afterSerialization || function (s) {\n    return s;\n  };\n\n  this.beforeDeserialization = options.beforeDeserialization || function (s) {\n    return s;\n  };\n\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  } // For NW apps, store data in the same directory where NW stores application data\n\n\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n}\n\n;\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\n\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {};\n\n  storage.mkdirp(dir, function (err) {\n    return callback(err);\n  });\n};\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\n\n\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data folder\");\n      }\n\n      home = path.join(home, appName);\n      break;\n\n    case 'darwin':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n\n    case 'linux':\n      home = process.env.HOME;\n\n      if (!home) {\n        throw new Error(\"Couldn't find the base application data directory\");\n      }\n\n      home = path.join(home, '.config', appName);\n      break;\n\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n};\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {},\n      toPersist = '',\n      self = this;\n\n  if (this.inMemoryOnly) {\n    return callback(null);\n  }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {\n      // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({\n        $$indexCreated: {\n          fieldName: fieldName,\n          unique: self.db.indexes[fieldName].unique,\n          sparse: self.db.indexes[fieldName].sparse\n        }\n      })) + '\\n';\n    }\n  });\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n/**\n * Queue a rewrite of the datafile\n */\n\n\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({\n    this: this,\n    fn: this.persistCachedDatabase,\n    arguments: []\n  });\n};\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\n\n\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this,\n      minInterval = 5000,\n      realInterval = Math.max(interval || 0, minInterval);\n  this.stopAutocompaction();\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\n\n\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) {\n    clearInterval(this.autocompactionIntervalId);\n  }\n};\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\n\n\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this,\n      toPersist = '',\n      callback = cb || function () {}; // In-memory only datastore\n\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) {\n    return callback(null);\n  }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\n\n\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n'),\n      dataById = {},\n      tdata = [],\n      i,\n      indexes = {},\n      corruptItems = -1 // Last line of every data file is usually blank so not really corrupt\n  ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  } // A bit lenient on corruption\n\n\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n  return {\n    data: tdata,\n    indexes: indexes\n  };\n};\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {},\n      self = this;\n\n  self.db.resetIndexes(); // In-memory only datastore\n\n  if (self.inMemoryOnly) {\n    return callback(null);\n  }\n\n  async.waterfall([function (cb) {\n    Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n      storage.ensureDatafileIntegrity(self.filename, function (err) {\n        storage.readFile(self.filename, 'utf8', function (err, rawData) {\n          if (err) {\n            return cb(err);\n          }\n\n          try {\n            var treatedData = self.treatRawData(rawData);\n          } catch (e) {\n            return cb(e);\n          } // Recreate all indexes in the datafile\n\n\n          Object.keys(treatedData.indexes).forEach(function (key) {\n            self.db.indexes[key] = new Index(treatedData.indexes[key]);\n          }); // Fill cached database (i.e. all indexes) with data\n\n          try {\n            self.db.resetIndexes(treatedData.data);\n          } catch (e) {\n            self.db.resetIndexes(); // Rollback any index which didn't fail\n\n            return cb(e);\n          }\n\n          self.db.persistence.persistCachedDatabase(cb);\n        });\n      });\n    });\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    self.db.executor.processBuffer();\n    return callback(null);\n  });\n}; // Interface\n\n\nmodule.exports = Persistence;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/nedb/lib/persistence.js"],"names":["storage","require","path","model","async","customUtils","Index","Persistence","options","i","j","randomString","db","inMemoryOnly","filename","corruptAlertThreshold","undefined","charAt","length","Error","afterSerialization","beforeDeserialization","s","uid","nodeWebkitAppName","console","log","getNWAppFilename","ensureDirectoryExists","dir","cb","callback","mkdirp","err","appName","relativeFilename","home","process","platform","env","LOCALAPPDATA","APPDATA","join","HOME","prototype","persistCachedDatabase","toPersist","self","getAllData","forEach","doc","serialize","Object","keys","indexes","fieldName","$$indexCreated","unique","sparse","crashSafeWriteFile","emit","compactDatafile","executor","push","this","fn","arguments","setAutocompactionInterval","interval","minInterval","realInterval","Math","max","stopAutocompaction","autocompactionIntervalId","setInterval","clearInterval","persistNewState","newDocs","appendFile","treatRawData","rawData","data","split","dataById","tdata","corruptItems","deserialize","_id","$$deleted","$$indexRemoved","e","floor","k","loadDatabase","resetIndexes","waterfall","dirname","ensureDatafileIntegrity","readFile","treatedData","key","persistence","processBuffer","module","exports"],"mappings":"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","sourcesContent":["/**\n * Handle every persistence-related task\n * The interface Datastore expects to be implemented is\n * * Persistence.loadDatabase(callback) and callback has signature err\n * * Persistence.persistNewState(newDocs, callback) where newDocs is an array of documents and callback has signature err\n */\n\nvar storage = require('./storage')\n  , path = require('path')\n  , model = require('./model')\n  , async = require('async')\n  , customUtils = require('./customUtils')\n  , Index = require('./indexes')\n  ;\n\n\n/**\n * Create a new Persistence object for database options.db\n * @param {Datastore} options.db\n * @param {Boolean} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n */\nfunction Persistence (options) {\n  var i, j, randomString;\n\n  this.db = options.db;\n  this.inMemoryOnly = this.db.inMemoryOnly;\n  this.filename = this.db.filename;\n  this.corruptAlertThreshold = options.corruptAlertThreshold !== undefined ? options.corruptAlertThreshold : 0.1;\n\n  if (!this.inMemoryOnly && this.filename && this.filename.charAt(this.filename.length - 1) === '~') {\n    throw new Error(\"The datafile name can't end with a ~, which is reserved for crash safe backup files\");\n  }\n\n  // After serialization and before deserialization hooks with some basic sanity checks\n  if (options.afterSerialization && !options.beforeDeserialization) {\n    throw new Error(\"Serialization hook defined but deserialization hook undefined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  if (!options.afterSerialization && options.beforeDeserialization) {\n    throw new Error(\"Serialization hook undefined but deserialization hook defined, cautiously refusing to start NeDB to prevent dataloss\");\n  }\n  this.afterSerialization = options.afterSerialization || function (s) { return s; };\n  this.beforeDeserialization = options.beforeDeserialization || function (s) { return s; };\n  for (i = 1; i < 30; i += 1) {\n    for (j = 0; j < 10; j += 1) {\n      randomString = customUtils.uid(i);\n      if (this.beforeDeserialization(this.afterSerialization(randomString)) !== randomString) {\n        throw new Error(\"beforeDeserialization is not the reverse of afterSerialization, cautiously refusing to start NeDB to prevent dataloss\");\n      }\n    }\n  }\n\n  // For NW apps, store data in the same directory where NW stores application data\n  if (this.filename && options.nodeWebkitAppName) {\n    console.log(\"==================================================================\");\n    console.log(\"WARNING: The nodeWebkitAppName option is deprecated\");\n    console.log(\"To get the path to the directory where Node Webkit stores the data\");\n    console.log(\"for your app, use the internal nw.gui module like this\");\n    console.log(\"require('nw.gui').App.dataPath\");\n    console.log(\"See https://github.com/rogerwang/node-webkit/issues/500\");\n    console.log(\"==================================================================\");\n    this.filename = Persistence.getNWAppFilename(options.nodeWebkitAppName, this.filename);\n  }\n};\n\n\n/**\n * Check if a directory exists and create it on the fly if it is not the case\n * cb is optional, signature: err\n */\nPersistence.ensureDirectoryExists = function (dir, cb) {\n  var callback = cb || function () {}\n    ;\n\n  storage.mkdirp(dir, function (err) { return callback(err); });\n};\n\n\n\n\n/**\n * Return the path the datafile if the given filename is relative to the directory where Node Webkit stores\n * data for this application. Probably the best place to store data\n */\nPersistence.getNWAppFilename = function (appName, relativeFilename) {\n  var home;\n\n  switch (process.platform) {\n    case 'win32':\n    case 'win64':\n      home = process.env.LOCALAPPDATA || process.env.APPDATA;\n      if (!home) { throw new Error(\"Couldn't find the base application data folder\"); }\n      home = path.join(home, appName);\n      break;\n    case 'darwin':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, 'Library', 'Application Support', appName);\n      break;\n    case 'linux':\n      home = process.env.HOME;\n      if (!home) { throw new Error(\"Couldn't find the base application data directory\"); }\n      home = path.join(home, '.config', appName);\n      break;\n    default:\n      throw new Error(\"Can't use the Node Webkit relative path for platform \" + process.platform);\n      break;\n  }\n\n  return path.join(home, 'nedb-data', relativeFilename);\n}\n\n\n/**\n * Persist cached database\n * This serves as a compaction function since the cache always contains only the number of documents in the collection\n * while the data file is append-only so it may grow larger\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.persistCachedDatabase = function (cb) {\n  var callback = cb || function () {}\n    , toPersist = ''\n    , self = this\n    ;\n\n  if (this.inMemoryOnly) { return callback(null); }\n\n  this.db.getAllData().forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n  Object.keys(this.db.indexes).forEach(function (fieldName) {\n    if (fieldName != \"_id\") {   // The special _id index is managed by datastore.js, the others need to be persisted\n      toPersist += self.afterSerialization(model.serialize({ $$indexCreated: { fieldName: fieldName, unique: self.db.indexes[fieldName].unique, sparse: self.db.indexes[fieldName].sparse }})) + '\\n';\n    }\n  });\n\n  storage.crashSafeWriteFile(this.filename, toPersist, function (err) {\n    if (err) { return callback(err); }\n    self.db.emit('compaction.done');\n    return callback(null);\n  });\n};\n\n\n/**\n * Queue a rewrite of the datafile\n */\nPersistence.prototype.compactDatafile = function () {\n  this.db.executor.push({ this: this, fn: this.persistCachedDatabase, arguments: [] });\n};\n\n\n/**\n * Set automatic compaction every interval ms\n * @param {Number} interval in milliseconds, with an enforced minimum of 5 seconds\n */\nPersistence.prototype.setAutocompactionInterval = function (interval) {\n  var self = this\n    , minInterval = 5000\n    , realInterval = Math.max(interval || 0, minInterval)\n    ;\n\n  this.stopAutocompaction();\n\n  this.autocompactionIntervalId = setInterval(function () {\n    self.compactDatafile();\n  }, realInterval);\n};\n\n\n/**\n * Stop autocompaction (do nothing if autocompaction was not running)\n */\nPersistence.prototype.stopAutocompaction = function () {\n  if (this.autocompactionIntervalId) { clearInterval(this.autocompactionIntervalId); }\n};\n\n\n/**\n * Persist new state for the given newDocs (can be insertion, update or removal)\n * Use an append-only format\n * @param {Array} newDocs Can be empty if no doc was updated/removed\n * @param {Function} cb Optional, signature: err\n */\nPersistence.prototype.persistNewState = function (newDocs, cb) {\n  var self = this\n    , toPersist = ''\n    , callback = cb || function () {}\n    ;\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  newDocs.forEach(function (doc) {\n    toPersist += self.afterSerialization(model.serialize(doc)) + '\\n';\n  });\n\n  if (toPersist.length === 0) { return callback(null); }\n\n  storage.appendFile(self.filename, toPersist, 'utf8', function (err) {\n    return callback(err);\n  });\n};\n\n\n/**\n * From a database's raw data, return the corresponding\n * machine understandable collection\n */\nPersistence.prototype.treatRawData = function (rawData) {\n  var data = rawData.split('\\n')\n    , dataById = {}\n    , tdata = []\n    , i\n    , indexes = {}\n    , corruptItems = -1   // Last line of every data file is usually blank so not really corrupt\n    ;\n\n  for (i = 0; i < data.length; i += 1) {\n    var doc;\n\n    try {\n      doc = model.deserialize(this.beforeDeserialization(data[i]));\n      if (doc._id) {\n        if (doc.$$deleted === true) {\n          delete dataById[doc._id];\n        } else {\n          dataById[doc._id] = doc;\n        }\n      } else if (doc.$$indexCreated && doc.$$indexCreated.fieldName != undefined) {\n        indexes[doc.$$indexCreated.fieldName] = doc.$$indexCreated;\n      } else if (typeof doc.$$indexRemoved === \"string\") {\n        delete indexes[doc.$$indexRemoved];\n      }\n    } catch (e) {\n      corruptItems += 1;\n    }\n  }\n\n  // A bit lenient on corruption\n  if (data.length > 0 && corruptItems / data.length > this.corruptAlertThreshold) {\n    throw new Error(\"More than \" + Math.floor(100 * this.corruptAlertThreshold) + \"% of the data file is corrupt, the wrong beforeDeserialization hook may be used. Cautiously refusing to start NeDB to prevent dataloss\");\n  }\n\n  Object.keys(dataById).forEach(function (k) {\n    tdata.push(dataById[k]);\n  });\n\n  return { data: tdata, indexes: indexes };\n};\n\n\n/**\n * Load the database\n * 1) Create all indexes\n * 2) Insert all data\n * 3) Compact the database\n * This means pulling data out of the data file or creating it if it doesn't exist\n * Also, all data is persisted right away, which has the effect of compacting the database file\n * This operation is very quick at startup for a big collection (60ms for ~10k docs)\n * @param {Function} cb Optional callback, signature: err\n */\nPersistence.prototype.loadDatabase = function (cb) {\n  var callback = cb || function () {}\n    , self = this\n    ;\n\n  self.db.resetIndexes();\n\n  // In-memory only datastore\n  if (self.inMemoryOnly) { return callback(null); }\n\n  async.waterfall([\n    function (cb) {\n      Persistence.ensureDirectoryExists(path.dirname(self.filename), function (err) {\n        storage.ensureDatafileIntegrity(self.filename, function (err) {\n          storage.readFile(self.filename, 'utf8', function (err, rawData) {\n            if (err) { return cb(err); }\n\n            try {\n              var treatedData = self.treatRawData(rawData);\n            } catch (e) {\n              return cb(e);\n            }\n\n            // Recreate all indexes in the datafile\n            Object.keys(treatedData.indexes).forEach(function (key) {\n              self.db.indexes[key] = new Index(treatedData.indexes[key]);\n            });\n\n            // Fill cached database (i.e. all indexes) with data\n            try {\n              self.db.resetIndexes(treatedData.data);\n            } catch (e) {\n              self.db.resetIndexes();   // Rollback any index which didn't fail\n              return cb(e);\n            }\n\n            self.db.persistence.persistCachedDatabase(cb);\n          });\n        });\n      });\n    }\n  ], function (err) {\n       if (err) { return callback(err); }\n\n       self.db.executor.processBuffer();\n       return callback(null);\n     });\n};\n\n\n// Interface\nmodule.exports = Persistence;\n"]},"metadata":{},"sourceType":"script"}