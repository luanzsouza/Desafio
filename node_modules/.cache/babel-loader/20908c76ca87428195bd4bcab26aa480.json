{"ast":null,"code":"var customUtils = require('./customUtils'),\n    model = require('./model'),\n    async = require('async'),\n    Executor = require('./executor'),\n    Index = require('./indexes'),\n    util = require('util'),\n    _ = require('underscore'),\n    Persistence = require('./persistence'),\n    Cursor = require('./cursor');\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\n\n\nfunction Datastore(options) {\n  var filename; // Retrocompatibility with v0.6 and before\n\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false; // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  } // Determine whether in memory or persistent\n\n\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  } // String comparison function\n\n\n  this.compareStrings = options.compareStrings; // Persistence handling\n\n  this.persistence = new Persistence({\n    db: this,\n    nodeWebkitAppName: options.nodeWebkitAppName,\n    afterSerialization: options.afterSerialization,\n    beforeDeserialization: options.beforeDeserialization,\n    corruptAlertThreshold: options.corruptAlertThreshold\n  }); // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n\n  this.executor = new Executor();\n\n  if (this.inMemoryOnly) {\n    this.executor.ready = true;\n  } // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n\n\n  this.indexes = {};\n  this.indexes._id = new Index({\n    fieldName: '_id',\n    unique: true\n  });\n  this.ttlIndexes = {}; // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n\n  if (this.autoload) {\n    this.loadDatabase(options.onload || function (err) {\n      if (err) {\n        throw err;\n      }\n    });\n  }\n}\n\nutil.inherits(Datastore, require('events').EventEmitter);\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\n\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({\n    this: this.persistence,\n    fn: this.persistence.loadDatabase,\n    arguments: arguments\n  }, true);\n};\n/**\n * Get an array of all the data in the database\n */\n\n\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n/**\n * Reset all currently defined indexes\n */\n\n\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err,\n      callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n\n  if (this.indexes[options.fieldName]) {\n    return callback(null);\n  }\n\n  this.indexes[options.fieldName] = new Index(options);\n\n  if (options.expireAfterSeconds !== undefined) {\n    this.ttlIndexes[options.fieldName] = options.expireAfterSeconds;\n  } // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  } // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n\n\n  this.persistence.persistNewState([{\n    $$indexCreated: options\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null);\n  });\n};\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\n\n\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n  this.persistence.persistNewState([{\n    $$indexRemoved: fieldName\n  }], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null);\n  });\n};\n/**\n * Add one or several document(s) to all indexes\n */\n\n\nDatastore.prototype.addToIndexes = function (doc) {\n  var i,\n      failingIndex,\n      error,\n      keys = Object.keys(this.indexes);\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  } // If an error happened, we need to rollback the insert on all other indexes\n\n\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Remove one or several document(s) from all indexes\n */\n\n\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\n\n\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i,\n      failingIndex,\n      error,\n      keys = Object.keys(this.indexes);\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  } // If an error happened, we need to rollback the update on all other indexes\n\n\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\n\n\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes),\n      self = this,\n      usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([// STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    } // For a $in match\n\n\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    } // For a comparison match\n\n\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    } // By default, return all the DB data\n\n\n    return cb(null, self.getAllData());\n  } // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) {\n      return callback(null, docs);\n    }\n\n    var expiredDocsIds = [],\n        validDocs = [],\n        ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n\n      if (valid) {\n        validDocs.push(doc);\n      } else {\n        expiredDocsIds.push(doc._id);\n      }\n    });\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({\n        _id: _id\n      }, {}, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\n\n\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {},\n      preparedDoc;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc);\n\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n/**\n * Create a new _id that's not already in use\n */\n\n\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16); // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n\n  return tentativeId;\n};\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\n\n\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc,\n      self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) {\n      preparedDoc.push(self.prepareDocumentForInsertion(doc));\n    });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n\n    if (preparedDoc._id === undefined) {\n      preparedDoc._id = this.createNewId();\n    }\n\n    var now = new Date();\n\n    if (this.timestampData && preparedDoc.createdAt === undefined) {\n      preparedDoc.createdAt = now;\n    }\n\n    if (this.timestampData && preparedDoc.updatedAt === undefined) {\n      preparedDoc.updatedAt = now;\n    }\n\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\n\n\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\n\n\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({\n    this: this,\n    fn: this._insert,\n    arguments: arguments\n  });\n};\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\n\n\nDatastore.prototype.count = function (query, callback) {\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\n\n\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {}; // callback is undefined, will return a cursor\n\n      break;\n\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n\n\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    var res = [],\n        i;\n\n    if (err) {\n      return callback(err);\n    }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n\n    return callback(null, res);\n  });\n  cursor.projection(projection);\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\n\n\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {}; // callback is undefined, will return a cursor\n\n      break;\n\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      } // If not assume projection is an object and callback undefined\n\n\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function (err, docs, callback) {\n    if (err) {\n      return callback(err);\n    }\n\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n  cursor.projection(projection).limit(1);\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\n\n\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback,\n      self = this,\n      numReplaced = 0,\n      multi,\n      upsert,\n      i;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  callback = cb || function () {};\n\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n  async.waterfall([function (cb) {\n    // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) {\n      return cb();\n    } // Need to use an internal function not tied to the executor to avoid deadlock\n\n\n    var cursor = new Cursor(self, query);\n\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) {\n        return callback(err);\n      }\n\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery); // updateQuery is a simple object with no modifier, use it as the document to insert\n\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) {\n            return callback(err);\n          }\n\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }, function () {\n    // Perform the update\n    var modifiedDoc,\n        modifications = [],\n        createdAt;\n    self.getCandidates(query, function (err, candidates) {\n      if (err) {\n        return callback(err);\n      } // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n\n\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n\n            if (self.timestampData) {\n              createdAt = candidates[i].createdAt;\n            }\n\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n\n            modifications.push({\n              oldDoc: candidates[i],\n              newDoc: modifiedDoc\n            });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      } // Change the docs in memory\n\n\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      } // Update the datafile\n\n\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) {\n          return callback(err);\n        }\n\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) {\n            updatedDocsDC.push(model.deepCopy(doc));\n          });\n\n          if (!multi) {\n            updatedDocsDC = updatedDocsDC[0];\n          }\n\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({\n    this: this,\n    fn: this._update,\n    arguments: arguments\n  });\n};\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\n\n\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback,\n      self = this,\n      numRemoved = 0,\n      removedDocs = [],\n      multi;\n\n  if (typeof options === 'function') {\n    cb = options;\n    options = {};\n  }\n\n  callback = cb || function () {};\n\n  multi = options.multi !== undefined ? options.multi : false;\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) {\n      return callback(err);\n    }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({\n            $$deleted: true,\n            _id: d._id\n          });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) {\n      return callback(err);\n    }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) {\n        return callback(err);\n      }\n\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({\n    this: this,\n    fn: this._remove,\n    arguments: arguments\n  });\n};\n\nmodule.exports = Datastore;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/nedb/lib/datastore.js"],"names":["customUtils","require","model","async","Executor","Index","util","_","Persistence","Cursor","Datastore","options","filename","inMemoryOnly","autoload","timestampData","length","compareStrings","persistence","db","nodeWebkitAppName","afterSerialization","beforeDeserialization","corruptAlertThreshold","executor","ready","indexes","_id","fieldName","unique","ttlIndexes","loadDatabase","onload","err","inherits","EventEmitter","prototype","push","this","fn","arguments","getAllData","getAll","resetIndexes","newData","self","Object","keys","forEach","i","reset","ensureIndex","cb","callback","Error","missingFieldName","expireAfterSeconds","undefined","insert","e","persistNewState","$$indexCreated","removeIndex","$$indexRemoved","addToIndexes","doc","failingIndex","error","remove","removeFromIndexes","updateIndexes","oldDoc","newDoc","update","revertUpdate","getCandidates","query","dontExpireStaleDocs","indexNames","usableQueryKeys","waterfall","k","isDate","intersection","getMatching","hasOwnProperty","$in","getBetweenBounds","docs","expiredDocsIds","validDocs","ttlIndexesFieldNames","valid","Date","now","getTime","eachSeries","_remove","_insert","preparedDoc","prepareDocumentForInsertion","_insertInCache","isArray","deepCopy","createNewId","tentativeId","uid","createdAt","updatedAt","checkObject","_insertMultipleDocsInCache","preparedDocs","failingI","count","cursor","exec","find","projection","res","findOne","limit","_update","updateQuery","numReplaced","multi","upsert","_exec","toBeInserted","modify","modifiedDoc","modifications","candidates","match","updatedDocs","pluck","returnUpdatedDocs","updatedDocsDC","numRemoved","removedDocs","d","$$deleted","module","exports"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAAzB;AAAA,IACIC,KAAK,GAAGD,OAAO,CAAC,SAAD,CADnB;AAAA,IAEIE,KAAK,GAAGF,OAAO,CAAC,OAAD,CAFnB;AAAA,IAGIG,QAAQ,GAAGH,OAAO,CAAC,YAAD,CAHtB;AAAA,IAIII,KAAK,GAAGJ,OAAO,CAAC,WAAD,CAJnB;AAAA,IAKIK,IAAI,GAAGL,OAAO,CAAC,MAAD,CALlB;AAAA,IAMIM,CAAC,GAAGN,OAAO,CAAC,YAAD,CANf;AAAA,IAOIO,WAAW,GAAGP,OAAO,CAAC,eAAD,CAPzB;AAAA,IAQIQ,MAAM,GAAGR,OAAO,CAAC,UAAD,CARpB;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASS,SAAT,CAAoBC,OAApB,EAA6B;AAC3B,MAAIC,QAAJ,CAD2B,CAG3B;;AACA,MAAI,OAAOD,OAAP,KAAmB,QAAvB,EAAiC;AAC/BC,IAAAA,QAAQ,GAAGD,OAAX;AACA,SAAKE,YAAL,GAAoB,KAApB,CAF+B,CAEF;AAC9B,GAHD,MAGO;AACLF,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACAC,IAAAA,QAAQ,GAAGD,OAAO,CAACC,QAAnB;AACA,SAAKC,YAAL,GAAoBF,OAAO,CAACE,YAAR,IAAwB,KAA5C;AACA,SAAKC,QAAL,GAAgBH,OAAO,CAACG,QAAR,IAAoB,KAApC;AACA,SAAKC,aAAL,GAAqBJ,OAAO,CAACI,aAAR,IAAyB,KAA9C;AACD,GAb0B,CAe3B;;;AACA,MAAI,CAACH,QAAD,IAAa,OAAOA,QAAP,KAAoB,QAAjC,IAA6CA,QAAQ,CAACI,MAAT,KAAoB,CAArE,EAAwE;AACtE,SAAKJ,QAAL,GAAgB,IAAhB;AACA,SAAKC,YAAL,GAAoB,IAApB;AACD,GAHD,MAGO;AACL,SAAKD,QAAL,GAAgBA,QAAhB;AACD,GArB0B,CAuB3B;;;AACA,OAAKK,cAAL,GAAsBN,OAAO,CAACM,cAA9B,CAxB2B,CA0B3B;;AACA,OAAKC,WAAL,GAAmB,IAAIV,WAAJ,CAAgB;AAAEW,IAAAA,EAAE,EAAE,IAAN;AAAYC,IAAAA,iBAAiB,EAAET,OAAO,CAACS,iBAAvC;AACGC,IAAAA,kBAAkB,EAAEV,OAAO,CAACU,kBAD/B;AAEGC,IAAAA,qBAAqB,EAAEX,OAAO,CAACW,qBAFlC;AAGGC,IAAAA,qBAAqB,EAAEZ,OAAO,CAACY;AAHlC,GAAhB,CAAnB,CA3B2B,CAiC3B;AACA;;AACA,OAAKC,QAAL,GAAgB,IAAIpB,QAAJ,EAAhB;;AACA,MAAI,KAAKS,YAAT,EAAuB;AAAE,SAAKW,QAAL,CAAcC,KAAd,GAAsB,IAAtB;AAA6B,GApC3B,CAsC3B;AACA;AACA;;;AACA,OAAKC,OAAL,GAAe,EAAf;AACA,OAAKA,OAAL,CAAaC,GAAb,GAAmB,IAAItB,KAAJ,CAAU;AAAEuB,IAAAA,SAAS,EAAE,KAAb;AAAoBC,IAAAA,MAAM,EAAE;AAA5B,GAAV,CAAnB;AACA,OAAKC,UAAL,GAAkB,EAAlB,CA3C2B,CA6C3B;AACA;;AACA,MAAI,KAAKhB,QAAT,EAAmB;AAAE,SAAKiB,YAAL,CAAkBpB,OAAO,CAACqB,MAAR,IAAkB,UAAUC,GAAV,EAAe;AACtE,UAAIA,GAAJ,EAAS;AAAE,cAAMA,GAAN;AAAY;AACxB,KAFoB;AAEhB;AACN;;AAED3B,IAAI,CAAC4B,QAAL,CAAcxB,SAAd,EAAyBT,OAAO,CAAC,QAAD,CAAP,CAAkBkC,YAA3C;AAGA;AACA;AACA;;AACAzB,SAAS,CAAC0B,SAAV,CAAoBL,YAApB,GAAmC,YAAY;AAC7C,OAAKP,QAAL,CAAca,IAAd,CAAmB;AAAEC,IAAAA,IAAI,EAAE,KAAKpB,WAAb;AAA0BqB,IAAAA,EAAE,EAAE,KAAKrB,WAAL,CAAiBa,YAA/C;AAA6DS,IAAAA,SAAS,EAAEA;AAAxE,GAAnB,EAAwG,IAAxG;AACD,CAFD;AAKA;AACA;AACA;;;AACA9B,SAAS,CAAC0B,SAAV,CAAoBK,UAApB,GAAiC,YAAY;AAC3C,SAAO,KAAKf,OAAL,CAAaC,GAAb,CAAiBe,MAAjB,EAAP;AACD,CAFD;AAKA;AACA;AACA;;;AACAhC,SAAS,CAAC0B,SAAV,CAAoBO,YAApB,GAAmC,UAAUC,OAAV,EAAmB;AACpD,MAAIC,IAAI,GAAG,IAAX;AAEAC,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAKrB,OAAjB,EAA0BsB,OAA1B,CAAkC,UAAUC,CAAV,EAAa;AAC7CJ,IAAAA,IAAI,CAACnB,OAAL,CAAauB,CAAb,EAAgBC,KAAhB,CAAsBN,OAAtB;AACD,GAFD;AAGD,CAND;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlC,SAAS,CAAC0B,SAAV,CAAoBe,WAApB,GAAkC,UAAUxC,OAAV,EAAmByC,EAAnB,EAAuB;AACvD,MAAInB,GAAJ;AAAA,MACIoB,QAAQ,GAAGD,EAAE,IAAI,YAAY,CAAE,CADnC;;AAGAzC,EAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;;AAEA,MAAI,CAACA,OAAO,CAACiB,SAAb,EAAwB;AACtBK,IAAAA,GAAG,GAAG,IAAIqB,KAAJ,CAAU,4CAAV,CAAN;AACArB,IAAAA,GAAG,CAACsB,gBAAJ,GAAuB,IAAvB;AACA,WAAOF,QAAQ,CAACpB,GAAD,CAAf;AACD;;AACD,MAAI,KAAKP,OAAL,CAAaf,OAAO,CAACiB,SAArB,CAAJ,EAAqC;AAAE,WAAOyB,QAAQ,CAAC,IAAD,CAAf;AAAwB;;AAE/D,OAAK3B,OAAL,CAAaf,OAAO,CAACiB,SAArB,IAAkC,IAAIvB,KAAJ,CAAUM,OAAV,CAAlC;;AACA,MAAIA,OAAO,CAAC6C,kBAAR,KAA+BC,SAAnC,EAA8C;AAAE,SAAK3B,UAAL,CAAgBnB,OAAO,CAACiB,SAAxB,IAAqCjB,OAAO,CAAC6C,kBAA7C;AAAkE,GAd3D,CAc8D;;;AAErH,MAAI;AACF,SAAK9B,OAAL,CAAaf,OAAO,CAACiB,SAArB,EAAgC8B,MAAhC,CAAuC,KAAKjB,UAAL,EAAvC;AACD,GAFD,CAEE,OAAOkB,CAAP,EAAU;AACV,WAAO,KAAKjC,OAAL,CAAaf,OAAO,CAACiB,SAArB,CAAP;AACA,WAAOyB,QAAQ,CAACM,CAAD,CAAf;AACD,GArBsD,CAuBvD;;;AACA,OAAKzC,WAAL,CAAiB0C,eAAjB,CAAiC,CAAC;AAAEC,IAAAA,cAAc,EAAElD;AAAlB,GAAD,CAAjC,EAAgE,UAAUsB,GAAV,EAAe;AAC7E,QAAIA,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,WAAOoB,QAAQ,CAAC,IAAD,CAAf;AACD,GAHD;AAID,CA5BD;AA+BA;AACA;AACA;AACA;AACA;;;AACA3C,SAAS,CAAC0B,SAAV,CAAoB0B,WAApB,GAAkC,UAAUlC,SAAV,EAAqBwB,EAArB,EAAyB;AACzD,MAAIC,QAAQ,GAAGD,EAAE,IAAI,YAAY,CAAE,CAAnC;;AAEA,SAAO,KAAK1B,OAAL,CAAaE,SAAb,CAAP;AAEA,OAAKV,WAAL,CAAiB0C,eAAjB,CAAiC,CAAC;AAAEG,IAAAA,cAAc,EAAEnC;AAAlB,GAAD,CAAjC,EAAkE,UAAUK,GAAV,EAAe;AAC/E,QAAIA,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,WAAOoB,QAAQ,CAAC,IAAD,CAAf;AACD,GAHD;AAID,CATD;AAYA;AACA;AACA;;;AACA3C,SAAS,CAAC0B,SAAV,CAAoB4B,YAApB,GAAmC,UAAUC,GAAV,EAAe;AAChD,MAAIhB,CAAJ;AAAA,MAAOiB,YAAP;AAAA,MAAqBC,KAArB;AAAA,MACIpB,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAY,KAAKrB,OAAjB,CADX;;AAIA,OAAKuB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,IAAI,CAAC/B,MAArB,EAA6BiC,CAAC,IAAI,CAAlC,EAAqC;AACnC,QAAI;AACF,WAAKvB,OAAL,CAAaqB,IAAI,CAACE,CAAD,CAAjB,EAAsBS,MAAtB,CAA6BO,GAA7B;AACD,KAFD,CAEE,OAAON,CAAP,EAAU;AACVO,MAAAA,YAAY,GAAGjB,CAAf;AACAkB,MAAAA,KAAK,GAAGR,CAAR;AACA;AACD;AACF,GAb+C,CAehD;;;AACA,MAAIQ,KAAJ,EAAW;AACT,SAAKlB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiB,YAAhB,EAA8BjB,CAAC,IAAI,CAAnC,EAAsC;AACpC,WAAKvB,OAAL,CAAaqB,IAAI,CAACE,CAAD,CAAjB,EAAsBmB,MAAtB,CAA6BH,GAA7B;AACD;;AAED,UAAME,KAAN;AACD;AACF,CAvBD;AA0BA;AACA;AACA;;;AACAzD,SAAS,CAAC0B,SAAV,CAAoBiC,iBAApB,GAAwC,UAAUJ,GAAV,EAAe;AACrD,MAAIpB,IAAI,GAAG,IAAX;AAEAC,EAAAA,MAAM,CAACC,IAAP,CAAY,KAAKrB,OAAjB,EAA0BsB,OAA1B,CAAkC,UAAUC,CAAV,EAAa;AAC7CJ,IAAAA,IAAI,CAACnB,OAAL,CAAauB,CAAb,EAAgBmB,MAAhB,CAAuBH,GAAvB;AACD,GAFD;AAGD,CAND;AASA;AACA;AACA;AACA;AACA;;;AACAvD,SAAS,CAAC0B,SAAV,CAAoBkC,aAApB,GAAoC,UAAUC,MAAV,EAAkBC,MAAlB,EAA0B;AAC5D,MAAIvB,CAAJ;AAAA,MAAOiB,YAAP;AAAA,MAAqBC,KAArB;AAAA,MACIpB,IAAI,GAAGD,MAAM,CAACC,IAAP,CAAY,KAAKrB,OAAjB,CADX;;AAIA,OAAKuB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGF,IAAI,CAAC/B,MAArB,EAA6BiC,CAAC,IAAI,CAAlC,EAAqC;AACnC,QAAI;AACF,WAAKvB,OAAL,CAAaqB,IAAI,CAACE,CAAD,CAAjB,EAAsBwB,MAAtB,CAA6BF,MAA7B,EAAqCC,MAArC;AACD,KAFD,CAEE,OAAOb,CAAP,EAAU;AACVO,MAAAA,YAAY,GAAGjB,CAAf;AACAkB,MAAAA,KAAK,GAAGR,CAAR;AACA;AACD;AACF,GAb2D,CAe5D;;;AACA,MAAIQ,KAAJ,EAAW;AACT,SAAKlB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGiB,YAAhB,EAA8BjB,CAAC,IAAI,CAAnC,EAAsC;AACpC,WAAKvB,OAAL,CAAaqB,IAAI,CAACE,CAAD,CAAjB,EAAsByB,YAAtB,CAAmCH,MAAnC,EAA2CC,MAA3C;AACD;;AAED,UAAML,KAAN;AACD;AACF,CAvBD;AA0BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAzD,SAAS,CAAC0B,SAAV,CAAoBuC,aAApB,GAAoC,UAAUC,KAAV,EAAiBC,mBAAjB,EAAsCxB,QAAtC,EAAgD;AAClF,MAAIyB,UAAU,GAAGhC,MAAM,CAACC,IAAP,CAAY,KAAKrB,OAAjB,CAAjB;AAAA,MACImB,IAAI,GAAG,IADX;AAAA,MAEIkC,eAFJ;;AAIA,MAAI,OAAOF,mBAAP,KAA+B,UAAnC,EAA+C;AAC7CxB,IAAAA,QAAQ,GAAGwB,mBAAX;AACAA,IAAAA,mBAAmB,GAAG,KAAtB;AACD;;AAED1E,EAAAA,KAAK,CAAC6E,SAAN,CAAgB,CAChB;AACA,YAAU5B,EAAV,EAAc;AACZ;AACA2B,IAAAA,eAAe,GAAG,EAAlB;AACAjC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,KAAZ,EAAmB5B,OAAnB,CAA2B,UAAUiC,CAAV,EAAa;AACtC,UAAI,OAAOL,KAAK,CAACK,CAAD,CAAZ,KAAoB,QAApB,IAAgC,OAAOL,KAAK,CAACK,CAAD,CAAZ,KAAoB,QAApD,IAAgE,OAAOL,KAAK,CAACK,CAAD,CAAZ,KAAoB,SAApF,IAAiG3E,IAAI,CAAC4E,MAAL,CAAYN,KAAK,CAACK,CAAD,CAAjB,CAAjG,IAA0HL,KAAK,CAACK,CAAD,CAAL,KAAa,IAA3I,EAAiJ;AAC/IF,QAAAA,eAAe,CAAC1C,IAAhB,CAAqB4C,CAArB;AACD;AACF,KAJD;AAKAF,IAAAA,eAAe,GAAGxE,CAAC,CAAC4E,YAAF,CAAeJ,eAAf,EAAgCD,UAAhC,CAAlB;;AACA,QAAIC,eAAe,CAAC/D,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,aAAOoC,EAAE,CAAC,IAAD,EAAOP,IAAI,CAACnB,OAAL,CAAaqD,eAAe,CAAC,CAAD,CAA5B,EAAiCK,WAAjC,CAA6CR,KAAK,CAACG,eAAe,CAAC,CAAD,CAAhB,CAAlD,CAAP,CAAT;AACD,KAXW,CAaZ;;;AACAA,IAAAA,eAAe,GAAG,EAAlB;AACAjC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,KAAZ,EAAmB5B,OAAnB,CAA2B,UAAUiC,CAAV,EAAa;AACtC,UAAIL,KAAK,CAACK,CAAD,CAAL,IAAYL,KAAK,CAACK,CAAD,CAAL,CAASI,cAAT,CAAwB,KAAxB,CAAhB,EAAgD;AAC9CN,QAAAA,eAAe,CAAC1C,IAAhB,CAAqB4C,CAArB;AACD;AACF,KAJD;AAKAF,IAAAA,eAAe,GAAGxE,CAAC,CAAC4E,YAAF,CAAeJ,eAAf,EAAgCD,UAAhC,CAAlB;;AACA,QAAIC,eAAe,CAAC/D,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,aAAOoC,EAAE,CAAC,IAAD,EAAOP,IAAI,CAACnB,OAAL,CAAaqD,eAAe,CAAC,CAAD,CAA5B,EAAiCK,WAAjC,CAA6CR,KAAK,CAACG,eAAe,CAAC,CAAD,CAAhB,CAAL,CAA0BO,GAAvE,CAAP,CAAT;AACD,KAvBW,CAyBZ;;;AACAP,IAAAA,eAAe,GAAG,EAAlB;AACAjC,IAAAA,MAAM,CAACC,IAAP,CAAY6B,KAAZ,EAAmB5B,OAAnB,CAA2B,UAAUiC,CAAV,EAAa;AACtC,UAAIL,KAAK,CAACK,CAAD,CAAL,KAAaL,KAAK,CAACK,CAAD,CAAL,CAASI,cAAT,CAAwB,KAAxB,KAAkCT,KAAK,CAACK,CAAD,CAAL,CAASI,cAAT,CAAwB,MAAxB,CAAlC,IAAqET,KAAK,CAACK,CAAD,CAAL,CAASI,cAAT,CAAwB,KAAxB,CAArE,IAAuGT,KAAK,CAACK,CAAD,CAAL,CAASI,cAAT,CAAwB,MAAxB,CAApH,CAAJ,EAA0J;AACxJN,QAAAA,eAAe,CAAC1C,IAAhB,CAAqB4C,CAArB;AACD;AACF,KAJD;AAKAF,IAAAA,eAAe,GAAGxE,CAAC,CAAC4E,YAAF,CAAeJ,eAAf,EAAgCD,UAAhC,CAAlB;;AACA,QAAIC,eAAe,CAAC/D,MAAhB,GAAyB,CAA7B,EAAgC;AAC9B,aAAOoC,EAAE,CAAC,IAAD,EAAOP,IAAI,CAACnB,OAAL,CAAaqD,eAAe,CAAC,CAAD,CAA5B,EAAiCQ,gBAAjC,CAAkDX,KAAK,CAACG,eAAe,CAAC,CAAD,CAAhB,CAAvD,CAAP,CAAT;AACD,KAnCW,CAqCZ;;;AACA,WAAO3B,EAAE,CAAC,IAAD,EAAOP,IAAI,CAACJ,UAAL,EAAP,CAAT;AACD,GAzCe,CA0ChB;AA1CgB,IA2Cd,UAAU+C,IAAV,EAAgB;AAChB,QAAIX,mBAAJ,EAAyB;AAAE,aAAOxB,QAAQ,CAAC,IAAD,EAAOmC,IAAP,CAAf;AAA8B;;AAEzD,QAAIC,cAAc,GAAG,EAArB;AAAA,QAAyBC,SAAS,GAAG,EAArC;AAAA,QAAyCC,oBAAoB,GAAG7C,MAAM,CAACC,IAAP,CAAYF,IAAI,CAACf,UAAjB,CAAhE;AAEA0D,IAAAA,IAAI,CAACxC,OAAL,CAAa,UAAUiB,GAAV,EAAe;AAC1B,UAAI2B,KAAK,GAAG,IAAZ;AACAD,MAAAA,oBAAoB,CAAC3C,OAArB,CAA6B,UAAUC,CAAV,EAAa;AACxC,YAAIgB,GAAG,CAAChB,CAAD,CAAH,KAAWQ,SAAX,IAAwBnD,IAAI,CAAC4E,MAAL,CAAYjB,GAAG,CAAChB,CAAD,CAAf,CAAxB,IAA+C4C,IAAI,CAACC,GAAL,KAAa7B,GAAG,CAAChB,CAAD,CAAH,CAAO8C,OAAP,KAAmBlD,IAAI,CAACf,UAAL,CAAgBmB,CAAhB,IAAqB,IAAxG,EAA8G;AAC5G2C,UAAAA,KAAK,GAAG,KAAR;AACD;AACF,OAJD;;AAKA,UAAIA,KAAJ,EAAW;AAAEF,QAAAA,SAAS,CAACrD,IAAV,CAAe4B,GAAf;AAAsB,OAAnC,MAAyC;AAAEwB,QAAAA,cAAc,CAACpD,IAAf,CAAoB4B,GAAG,CAACtC,GAAxB;AAA+B;AAC3E,KARD;AAUAxB,IAAAA,KAAK,CAAC6F,UAAN,CAAiBP,cAAjB,EAAiC,UAAU9D,GAAV,EAAeyB,EAAf,EAAmB;AAClDP,MAAAA,IAAI,CAACoD,OAAL,CAAa;AAAEtE,QAAAA,GAAG,EAAEA;AAAP,OAAb,EAA2B,EAA3B,EAA+B,UAAUM,GAAV,EAAe;AAC5C,YAAIA,GAAJ,EAAS;AAAE,iBAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,eAAOmB,EAAE,EAAT;AACD,OAHD;AAID,KALD,EAKG,UAAUnB,GAAV,EAAe;AAChB,aAAOoB,QAAQ,CAAC,IAAD,EAAOqC,SAAP,CAAf;AACD,KAPD;AAQD,GAlEe,CAAhB;AAmED,CA7ED;AAgFA;AACA;AACA;AACA;AACA;AACA;;;AACAhF,SAAS,CAAC0B,SAAV,CAAoB8D,OAApB,GAA8B,UAAU1B,MAAV,EAAkBpB,EAAlB,EAAsB;AAClD,MAAIC,QAAQ,GAAGD,EAAE,IAAI,YAAY,CAAE,CAAnC;AAAA,MACI+C,WADJ;;AAIA,MAAI;AACFA,IAAAA,WAAW,GAAG,KAAKC,2BAAL,CAAiC5B,MAAjC,CAAd;;AACA,SAAK6B,cAAL,CAAoBF,WAApB;AACD,GAHD,CAGE,OAAOxC,CAAP,EAAU;AACV,WAAON,QAAQ,CAACM,CAAD,CAAf;AACD;;AAED,OAAKzC,WAAL,CAAiB0C,eAAjB,CAAiCtD,IAAI,CAACgG,OAAL,CAAaH,WAAb,IAA4BA,WAA5B,GAA0C,CAACA,WAAD,CAA3E,EAA0F,UAAUlE,GAAV,EAAe;AACvG,QAAIA,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,WAAOoB,QAAQ,CAAC,IAAD,EAAOnD,KAAK,CAACqG,QAAN,CAAeJ,WAAf,CAAP,CAAf;AACD,GAHD;AAID,CAhBD;AAkBA;AACA;AACA;;;AACAzF,SAAS,CAAC0B,SAAV,CAAoBoE,WAApB,GAAkC,YAAY;AAC5C,MAAIC,WAAW,GAAGzG,WAAW,CAAC0G,GAAZ,CAAgB,EAAhB,CAAlB,CAD4C,CAE5C;;AACA,MAAI,KAAKhF,OAAL,CAAaC,GAAb,CAAiByD,WAAjB,CAA6BqB,WAA7B,EAA0CzF,MAA1C,GAAmD,CAAvD,EAA0D;AACxDyF,IAAAA,WAAW,GAAG,KAAKD,WAAL,EAAd;AACD;;AACD,SAAOC,WAAP;AACD,CAPD;AASA;AACA;AACA;AACA;AACA;;;AACA/F,SAAS,CAAC0B,SAAV,CAAoBgE,2BAApB,GAAkD,UAAU5B,MAAV,EAAkB;AAClE,MAAI2B,WAAJ;AAAA,MAAiBtD,IAAI,GAAG,IAAxB;;AAEA,MAAIvC,IAAI,CAACgG,OAAL,CAAa9B,MAAb,CAAJ,EAA0B;AACxB2B,IAAAA,WAAW,GAAG,EAAd;AACA3B,IAAAA,MAAM,CAACxB,OAAP,CAAe,UAAUiB,GAAV,EAAe;AAAEkC,MAAAA,WAAW,CAAC9D,IAAZ,CAAiBQ,IAAI,CAACuD,2BAAL,CAAiCnC,GAAjC,CAAjB;AAA0D,KAA1F;AACD,GAHD,MAGO;AACLkC,IAAAA,WAAW,GAAGjG,KAAK,CAACqG,QAAN,CAAe/B,MAAf,CAAd;;AACA,QAAI2B,WAAW,CAACxE,GAAZ,KAAoB8B,SAAxB,EAAmC;AAAE0C,MAAAA,WAAW,CAACxE,GAAZ,GAAkB,KAAK6E,WAAL,EAAlB;AAAuC;;AAC5E,QAAIV,GAAG,GAAG,IAAID,IAAJ,EAAV;;AACA,QAAI,KAAK9E,aAAL,IAAsBoF,WAAW,CAACQ,SAAZ,KAA0BlD,SAApD,EAA+D;AAAE0C,MAAAA,WAAW,CAACQ,SAAZ,GAAwBb,GAAxB;AAA8B;;AAC/F,QAAI,KAAK/E,aAAL,IAAsBoF,WAAW,CAACS,SAAZ,KAA0BnD,SAApD,EAA+D;AAAE0C,MAAAA,WAAW,CAACS,SAAZ,GAAwBd,GAAxB;AAA8B;;AAC/F5F,IAAAA,KAAK,CAAC2G,WAAN,CAAkBV,WAAlB;AACD;;AAED,SAAOA,WAAP;AACD,CAhBD;AAkBA;AACA;AACA;AACA;;;AACAzF,SAAS,CAAC0B,SAAV,CAAoBiE,cAApB,GAAqC,UAAUF,WAAV,EAAuB;AAC1D,MAAI7F,IAAI,CAACgG,OAAL,CAAaH,WAAb,CAAJ,EAA+B;AAC7B,SAAKW,0BAAL,CAAgCX,WAAhC;AACD,GAFD,MAEO;AACL,SAAKnC,YAAL,CAAkBmC,WAAlB;AACD;AACF,CAND;AAQA;AACA;AACA;AACA;AACA;;;AACAzF,SAAS,CAAC0B,SAAV,CAAoB0E,0BAApB,GAAiD,UAAUC,YAAV,EAAwB;AACvE,MAAI9D,CAAJ,EAAO+D,QAAP,EAAiB7C,KAAjB;;AAEA,OAAKlB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG8D,YAAY,CAAC/F,MAA7B,EAAqCiC,CAAC,IAAI,CAA1C,EAA6C;AAC3C,QAAI;AACF,WAAKe,YAAL,CAAkB+C,YAAY,CAAC9D,CAAD,CAA9B;AACD,KAFD,CAEE,OAAOU,CAAP,EAAU;AACVQ,MAAAA,KAAK,GAAGR,CAAR;AACAqD,MAAAA,QAAQ,GAAG/D,CAAX;AACA;AACD;AACF;;AAED,MAAIkB,KAAJ,EAAW;AACT,SAAKlB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG+D,QAAhB,EAA0B/D,CAAC,IAAI,CAA/B,EAAkC;AAChC,WAAKoB,iBAAL,CAAuB0C,YAAY,CAAC9D,CAAD,CAAnC;AACD;;AAED,UAAMkB,KAAN;AACD;AACF,CApBD;;AAsBAzD,SAAS,CAAC0B,SAAV,CAAoBsB,MAApB,GAA6B,YAAY;AACvC,OAAKlC,QAAL,CAAca,IAAd,CAAmB;AAAEC,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,EAAE,EAAE,KAAK2D,OAAvB;AAAgC1D,IAAAA,SAAS,EAAEA;AAA3C,GAAnB;AACD,CAFD;AAKA;AACA;AACA;AACA;;;AACA9B,SAAS,CAAC0B,SAAV,CAAoB6E,KAApB,GAA4B,UAASrC,KAAT,EAAgBvB,QAAhB,EAA0B;AACpD,MAAI6D,MAAM,GAAG,IAAIzG,MAAJ,CAAW,IAAX,EAAiBmE,KAAjB,EAAwB,UAAS3C,GAAT,EAAcuD,IAAd,EAAoBnC,QAApB,EAA8B;AACjE,QAAIpB,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,WAAOoB,QAAQ,CAAC,IAAD,EAAOmC,IAAI,CAACxE,MAAZ,CAAf;AACD,GAHY,CAAb;;AAKA,MAAI,OAAOqC,QAAP,KAAoB,UAAxB,EAAoC;AAClC6D,IAAAA,MAAM,CAACC,IAAP,CAAY9D,QAAZ;AACD,GAFD,MAEO;AACL,WAAO6D,MAAP;AACD;AACF,CAXD;AAcA;AACA;AACA;AACA;AACA;AACA;;;AACAxG,SAAS,CAAC0B,SAAV,CAAoBgF,IAApB,GAA2B,UAAUxC,KAAV,EAAiByC,UAAjB,EAA6BhE,QAA7B,EAAuC;AAChE,UAAQb,SAAS,CAACxB,MAAlB;AACE,SAAK,CAAL;AACEqG,MAAAA,UAAU,GAAG,EAAb,CADF,CAEE;;AACA;;AACF,SAAK,CAAL;AACE,UAAI,OAAOA,UAAP,KAAsB,UAA1B,EAAsC;AACpChE,QAAAA,QAAQ,GAAGgE,UAAX;AACAA,QAAAA,UAAU,GAAG,EAAb;AACD,OAJH,CAIM;;;AACJ;AAVJ;;AAaA,MAAIH,MAAM,GAAG,IAAIzG,MAAJ,CAAW,IAAX,EAAiBmE,KAAjB,EAAwB,UAAS3C,GAAT,EAAcuD,IAAd,EAAoBnC,QAApB,EAA8B;AACjE,QAAIiE,GAAG,GAAG,EAAV;AAAA,QAAcrE,CAAd;;AAEA,QAAIhB,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAElC,SAAKgB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGuC,IAAI,CAACxE,MAArB,EAA6BiC,CAAC,IAAI,CAAlC,EAAqC;AACnCqE,MAAAA,GAAG,CAACjF,IAAJ,CAASnC,KAAK,CAACqG,QAAN,CAAef,IAAI,CAACvC,CAAD,CAAnB,CAAT;AACD;;AACD,WAAOI,QAAQ,CAAC,IAAD,EAAOiE,GAAP,CAAf;AACD,GATY,CAAb;AAWAJ,EAAAA,MAAM,CAACG,UAAP,CAAkBA,UAAlB;;AACA,MAAI,OAAOhE,QAAP,KAAoB,UAAxB,EAAoC;AAClC6D,IAAAA,MAAM,CAACC,IAAP,CAAY9D,QAAZ;AACD,GAFD,MAEO;AACL,WAAO6D,MAAP;AACD;AACF,CA/BD;AAkCA;AACA;AACA;AACA;AACA;;;AACAxG,SAAS,CAAC0B,SAAV,CAAoBmF,OAApB,GAA8B,UAAU3C,KAAV,EAAiByC,UAAjB,EAA6BhE,QAA7B,EAAuC;AACnE,UAAQb,SAAS,CAACxB,MAAlB;AACE,SAAK,CAAL;AACEqG,MAAAA,UAAU,GAAG,EAAb,CADF,CAEE;;AACA;;AACF,SAAK,CAAL;AACE,UAAI,OAAOA,UAAP,KAAsB,UAA1B,EAAsC;AACpChE,QAAAA,QAAQ,GAAGgE,UAAX;AACAA,QAAAA,UAAU,GAAG,EAAb;AACD,OAJH,CAIM;;;AACJ;AAVJ;;AAaA,MAAIH,MAAM,GAAG,IAAIzG,MAAJ,CAAW,IAAX,EAAiBmE,KAAjB,EAAwB,UAAS3C,GAAT,EAAcuD,IAAd,EAAoBnC,QAApB,EAA8B;AACjE,QAAIpB,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,QAAIuD,IAAI,CAACxE,MAAL,KAAgB,CAApB,EAAuB;AACrB,aAAOqC,QAAQ,CAAC,IAAD,EAAOnD,KAAK,CAACqG,QAAN,CAAef,IAAI,CAAC,CAAD,CAAnB,CAAP,CAAf;AACD,KAFD,MAEO;AACL,aAAOnC,QAAQ,CAAC,IAAD,EAAO,IAAP,CAAf;AACD;AACF,GAPY,CAAb;AASA6D,EAAAA,MAAM,CAACG,UAAP,CAAkBA,UAAlB,EAA8BG,KAA9B,CAAoC,CAApC;;AACA,MAAI,OAAOnE,QAAP,KAAoB,UAAxB,EAAoC;AAClC6D,IAAAA,MAAM,CAACC,IAAP,CAAY9D,QAAZ;AACD,GAFD,MAEO;AACL,WAAO6D,MAAP;AACD;AACF,CA7BD;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxG,SAAS,CAAC0B,SAAV,CAAoBqF,OAApB,GAA8B,UAAU7C,KAAV,EAAiB8C,WAAjB,EAA8B/G,OAA9B,EAAuCyC,EAAvC,EAA2C;AACvE,MAAIC,QAAJ;AAAA,MACIR,IAAI,GAAG,IADX;AAAA,MAEI8E,WAAW,GAAG,CAFlB;AAAA,MAGIC,KAHJ;AAAA,MAGWC,MAHX;AAAA,MAII5E,CAJJ;;AAOA,MAAI,OAAOtC,OAAP,KAAmB,UAAvB,EAAmC;AAAEyC,IAAAA,EAAE,GAAGzC,OAAL;AAAcA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AAClE0C,EAAAA,QAAQ,GAAGD,EAAE,IAAI,YAAY,CAAE,CAA/B;;AACAwE,EAAAA,KAAK,GAAGjH,OAAO,CAACiH,KAAR,KAAkBnE,SAAlB,GAA8B9C,OAAO,CAACiH,KAAtC,GAA8C,KAAtD;AACAC,EAAAA,MAAM,GAAGlH,OAAO,CAACkH,MAAR,KAAmBpE,SAAnB,GAA+B9C,OAAO,CAACkH,MAAvC,GAAgD,KAAzD;AAEA1H,EAAAA,KAAK,CAAC6E,SAAN,CAAgB,CAChB,UAAU5B,EAAV,EAAc;AAAI;AAChB,QAAI,CAACyE,MAAL,EAAa;AAAE,aAAOzE,EAAE,EAAT;AAAc,KADjB,CAGZ;;;AACA,QAAI8D,MAAM,GAAG,IAAIzG,MAAJ,CAAWoC,IAAX,EAAiB+B,KAAjB,CAAb;;AACAsC,IAAAA,MAAM,CAACM,KAAP,CAAa,CAAb,EAAgBM,KAAhB,CAAsB,UAAU7F,GAAV,EAAeuD,IAAf,EAAqB;AACzC,UAAIvD,GAAJ,EAAS;AAAE,eAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,UAAIuD,IAAI,CAACxE,MAAL,KAAgB,CAApB,EAAuB;AACrB,eAAOoC,EAAE,EAAT;AACD,OAFD,MAEO;AACL,YAAI2E,YAAJ;;AAEA,YAAI;AACF7H,UAAAA,KAAK,CAAC2G,WAAN,CAAkBa,WAAlB,EADE,CAEF;;AACAK,UAAAA,YAAY,GAAGL,WAAf;AACD,SAJD,CAIE,OAAO/D,CAAP,EAAU;AACV;AACA;AACA,cAAI;AACFoE,YAAAA,YAAY,GAAG7H,KAAK,CAAC8H,MAAN,CAAa9H,KAAK,CAACqG,QAAN,CAAe3B,KAAf,EAAsB,IAAtB,CAAb,EAA0C8C,WAA1C,CAAf;AACD,WAFD,CAEE,OAAOzF,GAAP,EAAY;AACZ,mBAAOoB,QAAQ,CAACpB,GAAD,CAAf;AACD;AACF;;AAED,eAAOY,IAAI,CAACqD,OAAL,CAAa6B,YAAb,EAA2B,UAAU9F,GAAV,EAAeuC,MAAf,EAAuB;AACvD,cAAIvC,GAAJ,EAAS;AAAE,mBAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,iBAAOoB,QAAQ,CAAC,IAAD,EAAO,CAAP,EAAUmB,MAAV,EAAkB,IAAlB,CAAf;AACD,SAHM,CAAP;AAID;AACF,KA1BD;AA2BD,GAjCe,EAkCd,YAAY;AAAI;AAChB,QAAIyD,WAAJ;AAAA,QAAkBC,aAAa,GAAG,EAAlC;AAAA,QAAsCvB,SAAtC;AAEA9D,IAAAA,IAAI,CAAC8B,aAAL,CAAmBC,KAAnB,EAA0B,UAAU3C,GAAV,EAAekG,UAAf,EAA2B;AACnD,UAAIlG,GAAJ,EAAS;AAAE,eAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB,OADiB,CAGnD;AACA;;;AACA,UAAI;AACF,aAAKgB,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGkF,UAAU,CAACnH,MAA3B,EAAmCiC,CAAC,IAAI,CAAxC,EAA2C;AACzC,cAAI/C,KAAK,CAACkI,KAAN,CAAYD,UAAU,CAAClF,CAAD,CAAtB,EAA2B2B,KAA3B,MAAsCgD,KAAK,IAAID,WAAW,KAAK,CAA/D,CAAJ,EAAuE;AACrEA,YAAAA,WAAW,IAAI,CAAf;;AACA,gBAAI9E,IAAI,CAAC9B,aAAT,EAAwB;AAAE4F,cAAAA,SAAS,GAAGwB,UAAU,CAAClF,CAAD,CAAV,CAAc0D,SAA1B;AAAsC;;AAChEsB,YAAAA,WAAW,GAAG/H,KAAK,CAAC8H,MAAN,CAAaG,UAAU,CAAClF,CAAD,CAAvB,EAA4ByE,WAA5B,CAAd;;AACA,gBAAI7E,IAAI,CAAC9B,aAAT,EAAwB;AACtBkH,cAAAA,WAAW,CAACtB,SAAZ,GAAwBA,SAAxB;AACAsB,cAAAA,WAAW,CAACrB,SAAZ,GAAwB,IAAIf,IAAJ,EAAxB;AACD;;AACDqC,YAAAA,aAAa,CAAC7F,IAAd,CAAmB;AAAEkC,cAAAA,MAAM,EAAE4D,UAAU,CAAClF,CAAD,CAApB;AAAyBuB,cAAAA,MAAM,EAAEyD;AAAjC,aAAnB;AACD;AACF;AACF,OAbD,CAaE,OAAOhG,GAAP,EAAY;AACZ,eAAOoB,QAAQ,CAACpB,GAAD,CAAf;AACD,OApBkD,CAsBnD;;;AACA,UAAI;AACFY,QAAAA,IAAI,CAACyB,aAAL,CAAmB4D,aAAnB;AACD,OAFD,CAEE,OAAOjG,GAAP,EAAY;AACZ,eAAOoB,QAAQ,CAACpB,GAAD,CAAf;AACD,OA3BkD,CA6BnD;;;AACA,UAAIoG,WAAW,GAAG9H,CAAC,CAAC+H,KAAF,CAAQJ,aAAR,EAAuB,QAAvB,CAAlB;;AACArF,MAAAA,IAAI,CAAC3B,WAAL,CAAiB0C,eAAjB,CAAiCyE,WAAjC,EAA8C,UAAUpG,GAAV,EAAe;AAC3D,YAAIA,GAAJ,EAAS;AAAE,iBAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,YAAI,CAACtB,OAAO,CAAC4H,iBAAb,EAAgC;AAC9B,iBAAOlF,QAAQ,CAAC,IAAD,EAAOsE,WAAP,CAAf;AACD,SAFD,MAEO;AACL,cAAIa,aAAa,GAAG,EAApB;AACAH,UAAAA,WAAW,CAACrF,OAAZ,CAAoB,UAAUiB,GAAV,EAAe;AAAEuE,YAAAA,aAAa,CAACnG,IAAd,CAAmBnC,KAAK,CAACqG,QAAN,CAAetC,GAAf,CAAnB;AAA0C,WAA/E;;AACA,cAAI,CAAE2D,KAAN,EAAa;AAAEY,YAAAA,aAAa,GAAGA,aAAa,CAAC,CAAD,CAA7B;AAAmC;;AAClD,iBAAOnF,QAAQ,CAAC,IAAD,EAAOsE,WAAP,EAAoBa,aAApB,CAAf;AACD;AACF,OAVD;AAWD,KA1CD;AA2CD,GAhFe,CAAhB;AAiFD,CA9FD;;AAgGA9H,SAAS,CAAC0B,SAAV,CAAoBqC,MAApB,GAA6B,YAAY;AACvC,OAAKjD,QAAL,CAAca,IAAd,CAAmB;AAAEC,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,EAAE,EAAE,KAAKkF,OAAvB;AAAgCjF,IAAAA,SAAS,EAAEA;AAA3C,GAAnB;AACD,CAFD;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA9B,SAAS,CAAC0B,SAAV,CAAoB6D,OAApB,GAA8B,UAAUrB,KAAV,EAAiBjE,OAAjB,EAA0ByC,EAA1B,EAA8B;AAC1D,MAAIC,QAAJ;AAAA,MACIR,IAAI,GAAG,IADX;AAAA,MACiB4F,UAAU,GAAG,CAD9B;AAAA,MACiCC,WAAW,GAAG,EAD/C;AAAA,MACmDd,KADnD;;AAIA,MAAI,OAAOjH,OAAP,KAAmB,UAAvB,EAAmC;AAAEyC,IAAAA,EAAE,GAAGzC,OAAL;AAAcA,IAAAA,OAAO,GAAG,EAAV;AAAe;;AAClE0C,EAAAA,QAAQ,GAAGD,EAAE,IAAI,YAAY,CAAE,CAA/B;;AACAwE,EAAAA,KAAK,GAAGjH,OAAO,CAACiH,KAAR,KAAkBnE,SAAlB,GAA8B9C,OAAO,CAACiH,KAAtC,GAA8C,KAAtD;AAEA,OAAKjD,aAAL,CAAmBC,KAAnB,EAA0B,IAA1B,EAAgC,UAAU3C,GAAV,EAAekG,UAAf,EAA2B;AACzD,QAAIlG,GAAJ,EAAS;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAElC,QAAI;AACFkG,MAAAA,UAAU,CAACnF,OAAX,CAAmB,UAAU2F,CAAV,EAAa;AAC9B,YAAIzI,KAAK,CAACkI,KAAN,CAAYO,CAAZ,EAAe/D,KAAf,MAA0BgD,KAAK,IAAIa,UAAU,KAAK,CAAlD,CAAJ,EAA0D;AACxDA,UAAAA,UAAU,IAAI,CAAd;AACAC,UAAAA,WAAW,CAACrG,IAAZ,CAAiB;AAAEuG,YAAAA,SAAS,EAAE,IAAb;AAAmBjH,YAAAA,GAAG,EAAEgH,CAAC,CAAChH;AAA1B,WAAjB;AACAkB,UAAAA,IAAI,CAACwB,iBAAL,CAAuBsE,CAAvB;AACD;AACF,OAND;AAOD,KARD,CAQE,OAAO1G,GAAP,EAAY;AAAE,aAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAEvCY,IAAAA,IAAI,CAAC3B,WAAL,CAAiB0C,eAAjB,CAAiC8E,WAAjC,EAA8C,UAAUzG,GAAV,EAAe;AAC3D,UAAIA,GAAJ,EAAS;AAAE,eAAOoB,QAAQ,CAACpB,GAAD,CAAf;AAAuB;;AAClC,aAAOoB,QAAQ,CAAC,IAAD,EAAOoF,UAAP,CAAf;AACD,KAHD;AAID,GAjBD;AAkBD,CA3BD;;AA6BA/H,SAAS,CAAC0B,SAAV,CAAoBgC,MAApB,GAA6B,YAAY;AACvC,OAAK5C,QAAL,CAAca,IAAd,CAAmB;AAAEC,IAAAA,IAAI,EAAE,IAAR;AAAcC,IAAAA,EAAE,EAAE,KAAK0D,OAAvB;AAAgCzD,IAAAA,SAAS,EAAEA;AAA3C,GAAnB;AACD,CAFD;;AAMAqG,MAAM,CAACC,OAAP,GAAiBpI,SAAjB","sourcesContent":["var customUtils = require('./customUtils')\n  , model = require('./model')\n  , async = require('async')\n  , Executor = require('./executor')\n  , Index = require('./indexes')\n  , util = require('util')\n  , _ = require('underscore')\n  , Persistence = require('./persistence')\n  , Cursor = require('./cursor')\n  ;\n\n\n/**\n * Create a new collection\n * @param {String} options.filename Optional, datastore will be in-memory only if not provided\n * @param {Boolean} options.timestampData Optional, defaults to false. If set to true, createdAt and updatedAt will be created and populated automatically (if not specified by user)\n * @param {Boolean} options.inMemoryOnly Optional, defaults to false\n * @param {String} options.nodeWebkitAppName Optional, specify the name of your NW app if you want options.filename to be relative to the directory where\n *                                            Node Webkit stores application data such as cookies and local storage (the best place to store data in my opinion)\n * @param {Boolean} options.autoload Optional, defaults to false\n * @param {Function} options.onload Optional, if autoload is used this will be called after the load database with the error object as parameter. If you don't pass it the error will be thrown\n * @param {Function} options.afterSerialization/options.beforeDeserialization Optional, serialization hooks\n * @param {Number} options.corruptAlertThreshold Optional, threshold after which an alert is thrown if too much data is corrupt\n * @param {Function} options.compareStrings Optional, string comparison function that overrides default for sorting\n *\n * Event Emitter - Events\n * * compaction.done - Fired whenever a compaction operation was finished\n */\nfunction Datastore (options) {\n  var filename;\n\n  // Retrocompatibility with v0.6 and before\n  if (typeof options === 'string') {\n    filename = options;\n    this.inMemoryOnly = false;   // Default\n  } else {\n    options = options || {};\n    filename = options.filename;\n    this.inMemoryOnly = options.inMemoryOnly || false;\n    this.autoload = options.autoload || false;\n    this.timestampData = options.timestampData || false;\n  }\n\n  // Determine whether in memory or persistent\n  if (!filename || typeof filename !== 'string' || filename.length === 0) {\n    this.filename = null;\n    this.inMemoryOnly = true;\n  } else {\n    this.filename = filename;\n  }\n\n  // String comparison function\n  this.compareStrings = options.compareStrings;\n\n  // Persistence handling\n  this.persistence = new Persistence({ db: this, nodeWebkitAppName: options.nodeWebkitAppName\n                                      , afterSerialization: options.afterSerialization\n                                      , beforeDeserialization: options.beforeDeserialization\n                                      , corruptAlertThreshold: options.corruptAlertThreshold\n                                      });\n\n  // This new executor is ready if we don't use persistence\n  // If we do, it will only be ready once loadDatabase is called\n  this.executor = new Executor();\n  if (this.inMemoryOnly) { this.executor.ready = true; }\n\n  // Indexed by field name, dot notation can be used\n  // _id is always indexed and since _ids are generated randomly the underlying\n  // binary is always well-balanced\n  this.indexes = {};\n  this.indexes._id = new Index({ fieldName: '_id', unique: true });\n  this.ttlIndexes = {};\n\n  // Queue a load of the database right away and call the onload handler\n  // By default (no onload handler), if there is an error there, no operation will be possible so warn the user by throwing an exception\n  if (this.autoload) { this.loadDatabase(options.onload || function (err) {\n    if (err) { throw err; }\n  }); }\n}\n\nutil.inherits(Datastore, require('events').EventEmitter);\n\n\n/**\n * Load the database from the datafile, and trigger the execution of buffered commands if any\n */\nDatastore.prototype.loadDatabase = function () {\n  this.executor.push({ this: this.persistence, fn: this.persistence.loadDatabase, arguments: arguments }, true);\n};\n\n\n/**\n * Get an array of all the data in the database\n */\nDatastore.prototype.getAllData = function () {\n  return this.indexes._id.getAll();\n};\n\n\n/**\n * Reset all currently defined indexes\n */\nDatastore.prototype.resetIndexes = function (newData) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].reset(newData);\n  });\n};\n\n\n/**\n * Ensure an index is kept for this field. Same parameters as lib/indexes\n * For now this function is synchronous, we need to test how much time it takes\n * We use an async API for consistency with the rest of the code\n * @param {String} options.fieldName\n * @param {Boolean} options.unique\n * @param {Boolean} options.sparse\n * @param {Number} options.expireAfterSeconds - Optional, if set this index becomes a TTL index (only works on Date fields, not arrays of Date)\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.ensureIndex = function (options, cb) {\n  var err\n    , callback = cb || function () {};\n\n  options = options || {};\n\n  if (!options.fieldName) {\n    err = new Error(\"Cannot create an index without a fieldName\");\n    err.missingFieldName = true;\n    return callback(err);\n  }\n  if (this.indexes[options.fieldName]) { return callback(null); }\n\n  this.indexes[options.fieldName] = new Index(options);\n  if (options.expireAfterSeconds !== undefined) { this.ttlIndexes[options.fieldName] = options.expireAfterSeconds; }   // With this implementation index creation is not necessary to ensure TTL but we stick with MongoDB's API here\n\n  try {\n    this.indexes[options.fieldName].insert(this.getAllData());\n  } catch (e) {\n    delete this.indexes[options.fieldName];\n    return callback(e);\n  }\n\n  // We may want to force all options to be persisted including defaults, not just the ones passed the index creation function\n  this.persistence.persistNewState([{ $$indexCreated: options }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Remove an index\n * @param {String} fieldName\n * @param {Function} cb Optional callback, signature: err\n */\nDatastore.prototype.removeIndex = function (fieldName, cb) {\n  var callback = cb || function () {};\n\n  delete this.indexes[fieldName];\n\n  this.persistence.persistNewState([{ $$indexRemoved: fieldName }], function (err) {\n    if (err) { return callback(err); }\n    return callback(null);\n  });\n};\n\n\n/**\n * Add one or several document(s) to all indexes\n */\nDatastore.prototype.addToIndexes = function (doc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].insert(doc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the insert on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].remove(doc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Remove one or several document(s) from all indexes\n */\nDatastore.prototype.removeFromIndexes = function (doc) {\n  var self = this;\n\n  Object.keys(this.indexes).forEach(function (i) {\n    self.indexes[i].remove(doc);\n  });\n};\n\n\n/**\n * Update one or several documents in all indexes\n * To update multiple documents, oldDoc must be an array of { oldDoc, newDoc } pairs\n * If one update violates a constraint, all changes are rolled back\n */\nDatastore.prototype.updateIndexes = function (oldDoc, newDoc) {\n  var i, failingIndex, error\n    , keys = Object.keys(this.indexes)\n    ;\n\n  for (i = 0; i < keys.length; i += 1) {\n    try {\n      this.indexes[keys[i]].update(oldDoc, newDoc);\n    } catch (e) {\n      failingIndex = i;\n      error = e;\n      break;\n    }\n  }\n\n  // If an error happened, we need to rollback the update on all other indexes\n  if (error) {\n    for (i = 0; i < failingIndex; i += 1) {\n      this.indexes[keys[i]].revertUpdate(oldDoc, newDoc);\n    }\n\n    throw error;\n  }\n};\n\n\n/**\n * Return the list of candidates for a given query\n * Crude implementation for now, we return the candidates given by the first usable index if any\n * We try the following query types, in this order: basic match, $in match, comparison match\n * One way to make it better would be to enable the use of multiple indexes if the first usable index\n * returns too much data. I may do it in the future.\n *\n * Returned candidates will be scanned to find and remove all expired documents\n *\n * @param {Query} query\n * @param {Boolean} dontExpireStaleDocs Optional, defaults to false, if true don't remove stale docs. Useful for the remove function which shouldn't be impacted by expirations\n * @param {Function} callback Signature err, docs\n */\nDatastore.prototype.getCandidates = function (query, dontExpireStaleDocs, callback) {\n  var indexNames = Object.keys(this.indexes)\n    , self = this\n    , usableQueryKeys;\n\n  if (typeof dontExpireStaleDocs === 'function') {\n    callback = dontExpireStaleDocs;\n    dontExpireStaleDocs = false;\n  }\n\n  async.waterfall([\n  // STEP 1: get candidates list by checking indexes from most to least frequent usecase\n  function (cb) {\n    // For a basic match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (typeof query[k] === 'string' || typeof query[k] === 'number' || typeof query[k] === 'boolean' || util.isDate(query[k]) || query[k] === null) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]]));\n    }\n\n    // For a $in match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && query[k].hasOwnProperty('$in')) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getMatching(query[usableQueryKeys[0]].$in));\n    }\n\n    // For a comparison match\n    usableQueryKeys = [];\n    Object.keys(query).forEach(function (k) {\n      if (query[k] && (query[k].hasOwnProperty('$lt') || query[k].hasOwnProperty('$lte') || query[k].hasOwnProperty('$gt') || query[k].hasOwnProperty('$gte'))) {\n        usableQueryKeys.push(k);\n      }\n    });\n    usableQueryKeys = _.intersection(usableQueryKeys, indexNames);\n    if (usableQueryKeys.length > 0) {\n      return cb(null, self.indexes[usableQueryKeys[0]].getBetweenBounds(query[usableQueryKeys[0]]));\n    }\n\n    // By default, return all the DB data\n    return cb(null, self.getAllData());\n  }\n  // STEP 2: remove all expired documents\n  , function (docs) {\n    if (dontExpireStaleDocs) { return callback(null, docs); }\n\n    var expiredDocsIds = [], validDocs = [], ttlIndexesFieldNames = Object.keys(self.ttlIndexes);\n\n    docs.forEach(function (doc) {\n      var valid = true;\n      ttlIndexesFieldNames.forEach(function (i) {\n        if (doc[i] !== undefined && util.isDate(doc[i]) && Date.now() > doc[i].getTime() + self.ttlIndexes[i] * 1000) {\n          valid = false;\n        }\n      });\n      if (valid) { validDocs.push(doc); } else { expiredDocsIds.push(doc._id); }\n    });\n\n    async.eachSeries(expiredDocsIds, function (_id, cb) {\n      self._remove({ _id: _id }, {}, function (err) {\n        if (err) { return callback(err); }\n        return cb();\n      });\n    }, function (err) {\n      return callback(null, validDocs);\n    });\n  }]);\n};\n\n\n/**\n * Insert a new document\n * @param {Function} cb Optional callback, signature: err, insertedDoc\n *\n * @api private Use Datastore.insert which has the same signature\n */\nDatastore.prototype._insert = function (newDoc, cb) {\n  var callback = cb || function () {}\n    , preparedDoc\n    ;\n\n  try {\n    preparedDoc = this.prepareDocumentForInsertion(newDoc)\n    this._insertInCache(preparedDoc);\n  } catch (e) {\n    return callback(e);\n  }\n\n  this.persistence.persistNewState(util.isArray(preparedDoc) ? preparedDoc : [preparedDoc], function (err) {\n    if (err) { return callback(err); }\n    return callback(null, model.deepCopy(preparedDoc));\n  });\n};\n\n/**\n * Create a new _id that's not already in use\n */\nDatastore.prototype.createNewId = function () {\n  var tentativeId = customUtils.uid(16);\n  // Try as many times as needed to get an unused _id. As explained in customUtils, the probability of this ever happening is extremely small, so this is O(1)\n  if (this.indexes._id.getMatching(tentativeId).length > 0) {\n    tentativeId = this.createNewId();\n  }\n  return tentativeId;\n};\n\n/**\n * Prepare a document (or array of documents) to be inserted in a database\n * Meaning adds _id and timestamps if necessary on a copy of newDoc to avoid any side effect on user input\n * @api private\n */\nDatastore.prototype.prepareDocumentForInsertion = function (newDoc) {\n  var preparedDoc, self = this;\n\n  if (util.isArray(newDoc)) {\n    preparedDoc = [];\n    newDoc.forEach(function (doc) { preparedDoc.push(self.prepareDocumentForInsertion(doc)); });\n  } else {\n    preparedDoc = model.deepCopy(newDoc);\n    if (preparedDoc._id === undefined) { preparedDoc._id = this.createNewId(); }\n    var now = new Date();\n    if (this.timestampData && preparedDoc.createdAt === undefined) { preparedDoc.createdAt = now; }\n    if (this.timestampData && preparedDoc.updatedAt === undefined) { preparedDoc.updatedAt = now; }\n    model.checkObject(preparedDoc);\n  }\n\n  return preparedDoc;\n};\n\n/**\n * If newDoc is an array of documents, this will insert all documents in the cache\n * @api private\n */\nDatastore.prototype._insertInCache = function (preparedDoc) {\n  if (util.isArray(preparedDoc)) {\n    this._insertMultipleDocsInCache(preparedDoc);\n  } else {\n    this.addToIndexes(preparedDoc);\n  }\n};\n\n/**\n * If one insertion fails (e.g. because of a unique constraint), roll back all previous\n * inserts and throws the error\n * @api private\n */\nDatastore.prototype._insertMultipleDocsInCache = function (preparedDocs) {\n  var i, failingI, error;\n\n  for (i = 0; i < preparedDocs.length; i += 1) {\n    try {\n      this.addToIndexes(preparedDocs[i]);\n    } catch (e) {\n      error = e;\n      failingI = i;\n      break;\n    }\n  }\n\n  if (error) {\n    for (i = 0; i < failingI; i += 1) {\n      this.removeFromIndexes(preparedDocs[i]);\n    }\n\n    throw error;\n  }\n};\n\nDatastore.prototype.insert = function () {\n  this.executor.push({ this: this, fn: this._insert, arguments: arguments });\n};\n\n\n/**\n * Count all documents matching the query\n * @param {Object} query MongoDB-style query\n */\nDatastore.prototype.count = function(query, callback) {\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    return callback(null, docs.length);\n  });\n\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find all documents matching the query\n * If no callback is passed, we return the cursor so that user can limit, skip and finally exec\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.find = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    var res = [], i;\n\n    if (err) { return callback(err); }\n\n    for (i = 0; i < docs.length; i += 1) {\n      res.push(model.deepCopy(docs[i]));\n    }\n    return callback(null, res);\n  });\n\n  cursor.projection(projection);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Find one document matching the query\n * @param {Object} query MongoDB-style query\n * @param {Object} projection MongoDB-style projection\n */\nDatastore.prototype.findOne = function (query, projection, callback) {\n  switch (arguments.length) {\n    case 1:\n      projection = {};\n      // callback is undefined, will return a cursor\n      break;\n    case 2:\n      if (typeof projection === 'function') {\n        callback = projection;\n        projection = {};\n      }   // If not assume projection is an object and callback undefined\n      break;\n  }\n\n  var cursor = new Cursor(this, query, function(err, docs, callback) {\n    if (err) { return callback(err); }\n    if (docs.length === 1) {\n      return callback(null, model.deepCopy(docs[0]));\n    } else {\n      return callback(null, null);\n    }\n  });\n\n  cursor.projection(projection).limit(1);\n  if (typeof callback === 'function') {\n    cursor.exec(callback);\n  } else {\n    return cursor;\n  }\n};\n\n\n/**\n * Update all docs matching query\n * @param {Object} query\n * @param {Object} updateQuery\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n *                 options.upsert If true, document is inserted if the query doesn't match anything\n *                 options.returnUpdatedDocs Defaults to false, if true return as third argument the array of updated matched documents (even if no change actually took place)\n * @param {Function} cb Optional callback, signature: (err, numAffected, affectedDocuments, upsert)\n *                      If update was an upsert, upsert flag is set to true\n *                      affectedDocuments can be one of the following:\n *                        * For an upsert, the upserted document\n *                        * For an update with returnUpdatedDocs option false, null\n *                        * For an update with returnUpdatedDocs true and multi false, the updated document\n *                        * For an update with returnUpdatedDocs true and multi true, the array of updated documents\n *\n * WARNING: The API was changed between v1.7.4 and v1.8, for consistency and readability reasons. Prior and including to v1.7.4,\n *          the callback signature was (err, numAffected, updated) where updated was the updated document in case of an upsert\n *          or the array of updated documents for an update if the returnUpdatedDocs option was true. That meant that the type of\n *          affectedDocuments in a non multi update depended on whether there was an upsert or not, leaving only two ways for the\n *          user to check whether an upsert had occured: checking the type of affectedDocuments or running another find query on\n *          the whole dataset to check its size. Both options being ugly, the breaking change was necessary.\n *\n * @api private Use Datastore.update which has the same signature\n */\nDatastore.prototype._update = function (query, updateQuery, options, cb) {\n  var callback\n    , self = this\n    , numReplaced = 0\n    , multi, upsert\n    , i\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n  upsert = options.upsert !== undefined ? options.upsert : false;\n\n  async.waterfall([\n  function (cb) {   // If upsert option is set, check whether we need to insert the doc\n    if (!upsert) { return cb(); }\n\n    // Need to use an internal function not tied to the executor to avoid deadlock\n    var cursor = new Cursor(self, query);\n    cursor.limit(1)._exec(function (err, docs) {\n      if (err) { return callback(err); }\n      if (docs.length === 1) {\n        return cb();\n      } else {\n        var toBeInserted;\n\n        try {\n          model.checkObject(updateQuery);\n          // updateQuery is a simple object with no modifier, use it as the document to insert\n          toBeInserted = updateQuery;\n        } catch (e) {\n          // updateQuery contains modifiers, use the find query as the base,\n          // strip it from all operators and update it according to updateQuery\n          try {\n            toBeInserted = model.modify(model.deepCopy(query, true), updateQuery);\n          } catch (err) {\n            return callback(err);\n          }\n        }\n\n        return self._insert(toBeInserted, function (err, newDoc) {\n          if (err) { return callback(err); }\n          return callback(null, 1, newDoc, true);\n        });\n      }\n    });\n  }\n  , function () {   // Perform the update\n    var modifiedDoc , modifications = [], createdAt;\n\n    self.getCandidates(query, function (err, candidates) {\n      if (err) { return callback(err); }\n\n      // Preparing update (if an error is thrown here neither the datafile nor\n      // the in-memory indexes are affected)\n      try {\n        for (i = 0; i < candidates.length; i += 1) {\n          if (model.match(candidates[i], query) && (multi || numReplaced === 0)) {\n            numReplaced += 1;\n            if (self.timestampData) { createdAt = candidates[i].createdAt; }\n            modifiedDoc = model.modify(candidates[i], updateQuery);\n            if (self.timestampData) {\n              modifiedDoc.createdAt = createdAt;\n              modifiedDoc.updatedAt = new Date();\n            }\n            modifications.push({ oldDoc: candidates[i], newDoc: modifiedDoc });\n          }\n        }\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Change the docs in memory\n      try {\n        self.updateIndexes(modifications);\n      } catch (err) {\n        return callback(err);\n      }\n\n      // Update the datafile\n      var updatedDocs = _.pluck(modifications, 'newDoc');\n      self.persistence.persistNewState(updatedDocs, function (err) {\n        if (err) { return callback(err); }\n        if (!options.returnUpdatedDocs) {\n          return callback(null, numReplaced);\n        } else {\n          var updatedDocsDC = [];\n          updatedDocs.forEach(function (doc) { updatedDocsDC.push(model.deepCopy(doc)); });\n          if (! multi) { updatedDocsDC = updatedDocsDC[0]; }\n          return callback(null, numReplaced, updatedDocsDC);\n        }\n      });\n    });\n  }]);\n};\n\nDatastore.prototype.update = function () {\n  this.executor.push({ this: this, fn: this._update, arguments: arguments });\n};\n\n\n/**\n * Remove all docs matching the query\n * For now very naive implementation (similar to update)\n * @param {Object} query\n * @param {Object} options Optional options\n *                 options.multi If true, can update multiple documents (defaults to false)\n * @param {Function} cb Optional callback, signature: err, numRemoved\n *\n * @api private Use Datastore.remove which has the same signature\n */\nDatastore.prototype._remove = function (query, options, cb) {\n  var callback\n    , self = this, numRemoved = 0, removedDocs = [], multi\n    ;\n\n  if (typeof options === 'function') { cb = options; options = {}; }\n  callback = cb || function () {};\n  multi = options.multi !== undefined ? options.multi : false;\n\n  this.getCandidates(query, true, function (err, candidates) {\n    if (err) { return callback(err); }\n\n    try {\n      candidates.forEach(function (d) {\n        if (model.match(d, query) && (multi || numRemoved === 0)) {\n          numRemoved += 1;\n          removedDocs.push({ $$deleted: true, _id: d._id });\n          self.removeFromIndexes(d);\n        }\n      });\n    } catch (err) { return callback(err); }\n\n    self.persistence.persistNewState(removedDocs, function (err) {\n      if (err) { return callback(err); }\n      return callback(null, numRemoved);\n    });\n  });\n};\n\nDatastore.prototype.remove = function () {\n  this.executor.push({ this: this, fn: this._remove, arguments: arguments });\n};\n\n\n\nmodule.exports = Datastore;\n"]},"metadata":{},"sourceType":"script"}