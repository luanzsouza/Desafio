{"ast":null,"code":"/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\n\n\nfunction BinarySearchTree(options) {\n  options = options || {};\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n\n  if (options.hasOwnProperty('key')) {\n    this.key = options.key;\n  }\n\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n} // ================================\n// Methods used to test the tree\n// ================================\n\n/**\n * Get the descendant with max key\n */\n\n\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the maximum key\n */\n\n\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n/**\n * Get the descendant with min key\n */\n\n\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant();\n  } else {\n    return this;\n  }\n};\n/**\n * Get the minimum key\n */\n\n\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\n\n\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  test(this.key, this.data);\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(test);\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(test);\n  }\n};\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\n\n\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n/**\n * Check that all pointers are coherent in this tree\n */\n\n\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) {\n      throw new Error('Parent pointer broken for key ' + this.key);\n    }\n\n    this.right.checkInternalPointers();\n  }\n};\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\n\n\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n\n  if (this.parent) {\n    throw new Error(\"The root shouldn't have a parent\");\n  }\n};\n/**\n * Get number of keys inserted\n */\n\n\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) {\n    return 0;\n  }\n\n  res = 1;\n\n  if (this.left) {\n    res += this.left.getNumberOfKeys();\n  }\n\n  if (this.right) {\n    res += this.right.getNumberOfKeys();\n  }\n\n  return res;\n}; // ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\n\n\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n  return new this.constructor(options);\n};\n/**\n * Create the left child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n  return leftChild;\n};\n/**\n * Create the right child of this BST and return it\n */\n\n\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n  return rightChild;\n};\n/**\n * Insert a new element\n */\n\n\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  } // Same key as root\n\n\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({\n        key: key,\n        value: value\n      });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({\n        key: key,\n        value: value\n      });\n    }\n  }\n};\n/**\n * Search for all data corresponding to a key\n */\n\n\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  }\n\n  if (this.compareKeys(this.key, key) === 0) {\n    return this.data;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\n\n\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$gte) >= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$gt) > 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$gt) > 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$gte) >= 0;\n    };\n  }\n};\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\n\n\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this; // No lower bound\n\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () {\n      return true;\n    };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) {\n        return self.compareKeys(key, query.$lte) <= 0;\n      };\n    } else {\n      return function (key) {\n        return self.compareKeys(key, query.$lt) < 0;\n      };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) {\n      return self.compareKeys(key, query.$lt) < 0;\n    };\n  } else {\n    return function (key) {\n      return self.compareKeys(key, query.$lte) <= 0;\n    };\n  }\n}; // Append all elements in toAppend to array\n\n\nfunction append(array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\n\n\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) {\n    return [];\n  } // Empty tree\n\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) {\n    append(res, this.left.betweenBounds(query, lbm, ubm));\n  }\n\n  if (lbm(this.key) && ubm(this.key)) {\n    append(res, this.data);\n  }\n\n  if (ubm(this.key) && this.right) {\n    append(res, this.right.betweenBounds(query, lbm, ubm));\n  }\n\n  return res;\n};\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) {\n    return false;\n  } // The leaf is itself a root\n\n\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\n\n\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) {\n    child = this.left;\n  }\n\n  if (!this.left && this.right) {\n    child = this.right;\n  }\n\n  if (!child) {\n    return false;\n  } // Root\n\n\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n    this.left = null;\n\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\n\n\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [],\n      replaceWith,\n      self = this;\n\n  if (!this.hasOwnProperty('key')) {\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      this.left.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) {\n      this.right.delete(key, value);\n    }\n\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) {\n    return;\n  } // Delete only a value\n\n\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) {\n        newData.push(d);\n      }\n    });\n    self.data = newData;\n    return;\n  } // Delete the whole node\n\n\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  } // We are in the case where the node to delete has two children\n\n\n  if (Math.random() >= 0.5) {\n    // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.left = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n\n      if (replaceWith.left) {\n        replaceWith.left.parent = replaceWith.parent;\n      }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {\n      // Special case\n      this.right = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n\n      if (replaceWith.right) {\n        replaceWith.right.parent = replaceWith.parent;\n      }\n    }\n  }\n};\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\n\n\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) {\n    this.left.executeOnEveryNode(fn);\n  }\n\n  fn(this);\n\n  if (this.right) {\n    this.right.executeOnEveryNode(fn);\n  }\n};\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\n\n\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n  console.log(spacing + \"* \" + this.key);\n\n  if (printData) {\n    console.log(spacing + \"* \" + this.data);\n  }\n\n  if (!this.left && !this.right) {\n    return;\n  }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n}; // Interface\n\n\nmodule.exports = BinarySearchTree;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/binary-search-tree/lib/bst.js"],"names":["customUtils","require","BinarySearchTree","options","left","right","parent","undefined","hasOwnProperty","key","data","value","unique","compareKeys","defaultCompareKeysFunction","checkValueEquality","defaultCheckValueEquality","prototype","getMaxKeyDescendant","getMaxKey","getMinKeyDescendant","getMinKey","checkAllNodesFullfillCondition","test","checkNodeOrdering","self","k","Error","checkInternalPointers","checkIsBST","getNumberOfKeys","res","createSimilar","constructor","createLeftChild","leftChild","createRightChild","rightChild","insert","push","err","errorType","search","getLowerBoundMatcher","query","$gte","$gt","getUpperBoundMatcher","$lte","$lt","append","array","toAppend","i","length","betweenBounds","lbm","ubm","deleteIfLeaf","deleteIfOnlyOneChild","child","delete","newData","replaceWith","forEach","d","Math","random","executeOnEveryNode","fn","prettyPrint","printData","spacing","console","log","module","exports"],"mappings":"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","sourcesContent":["/**\n * Simple binary search tree\n */\nvar customUtils = require('./customUtils');\n\n\n/**\n * Constructor\n * @param {Object} options Optional\n * @param {Boolean}  options.unique Whether to enforce a 'unique' constraint on the key or not\n * @param {Key}      options.key Initialize this BST's key with key\n * @param {Value}    options.value Initialize this BST's data with [value]\n * @param {Function} options.compareKeys Initialize this BST's compareKeys\n */\nfunction BinarySearchTree (options) {\n  options = options || {};\n\n  this.left = null;\n  this.right = null;\n  this.parent = options.parent !== undefined ? options.parent : null;\n  if (options.hasOwnProperty('key')) { this.key = options.key; }\n  this.data = options.hasOwnProperty('value') ? [options.value] : [];\n  this.unique = options.unique || false;\n\n  this.compareKeys = options.compareKeys || customUtils.defaultCompareKeysFunction;\n  this.checkValueEquality = options.checkValueEquality || customUtils.defaultCheckValueEquality;\n}\n\n\n// ================================\n// Methods used to test the tree\n// ================================\n\n\n/**\n * Get the descendant with max key\n */\nBinarySearchTree.prototype.getMaxKeyDescendant = function () {\n  if (this.right) {\n    return this.right.getMaxKeyDescendant();\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the maximum key\n */\nBinarySearchTree.prototype.getMaxKey = function () {\n  return this.getMaxKeyDescendant().key;\n};\n\n\n/**\n * Get the descendant with min key\n */\nBinarySearchTree.prototype.getMinKeyDescendant = function () {\n  if (this.left) {\n    return this.left.getMinKeyDescendant()\n  } else {\n    return this;\n  }\n};\n\n\n/**\n * Get the minimum key\n */\nBinarySearchTree.prototype.getMinKey = function () {\n  return this.getMinKeyDescendant().key;\n};\n\n\n/**\n * Check that all nodes (incl. leaves) fullfil condition given by fn\n * test is a function passed every (key, data) and which throws if the condition is not met\n */\nBinarySearchTree.prototype.checkAllNodesFullfillCondition = function (test) {\n  if (!this.hasOwnProperty('key')) { return; }\n\n  test(this.key, this.data);\n  if (this.left) { this.left.checkAllNodesFullfillCondition(test); }\n  if (this.right) { this.right.checkAllNodesFullfillCondition(test); }\n};\n\n\n/**\n * Check that the core BST properties on node ordering are verified\n * Throw if they aren't\n */\nBinarySearchTree.prototype.checkNodeOrdering = function () {\n  var self = this;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.left) {\n    this.left.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) >= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.left.checkNodeOrdering();\n  }\n\n  if (this.right) {\n    this.right.checkAllNodesFullfillCondition(function (k) {\n      if (self.compareKeys(k, self.key) <= 0) {\n        throw new Error('Tree with root ' + self.key + ' is not a binary search tree');\n      }\n    });\n    this.right.checkNodeOrdering();\n  }\n};\n\n\n/**\n * Check that all pointers are coherent in this tree\n */\nBinarySearchTree.prototype.checkInternalPointers = function () {\n  if (this.left) {\n    if (this.left.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.left.checkInternalPointers();\n  }\n\n  if (this.right) {\n    if (this.right.parent !== this) { throw new Error('Parent pointer broken for key ' + this.key); }\n    this.right.checkInternalPointers();\n  }\n};\n\n\n/**\n * Check that a tree is a BST as defined here (node ordering and pointer references)\n */\nBinarySearchTree.prototype.checkIsBST = function () {\n  this.checkNodeOrdering();\n  this.checkInternalPointers();\n  if (this.parent) { throw new Error(\"The root shouldn't have a parent\"); }\n};\n\n\n/**\n * Get number of keys inserted\n */\nBinarySearchTree.prototype.getNumberOfKeys = function () {\n  var res;\n\n  if (!this.hasOwnProperty('key')) { return 0; }\n\n  res = 1;\n  if (this.left) { res += this.left.getNumberOfKeys(); }\n  if (this.right) { res += this.right.getNumberOfKeys(); }\n\n  return res;\n};\n\n\n\n// ============================================\n// Methods used to actually work on the tree\n// ============================================\n\n/**\n * Create a BST similar (i.e. same options except for key and value) to the current one\n * Use the same constructor (i.e. BinarySearchTree, AVLTree etc)\n * @param {Object} options see constructor\n */\nBinarySearchTree.prototype.createSimilar = function (options) {\n  options = options || {};\n  options.unique = this.unique;\n  options.compareKeys = this.compareKeys;\n  options.checkValueEquality = this.checkValueEquality;\n\n  return new this.constructor(options);\n};\n\n\n/**\n * Create the left child of this BST and return it\n */\nBinarySearchTree.prototype.createLeftChild = function (options) {\n  var leftChild = this.createSimilar(options);\n  leftChild.parent = this;\n  this.left = leftChild;\n\n  return leftChild;\n};\n\n\n/**\n * Create the right child of this BST and return it\n */\nBinarySearchTree.prototype.createRightChild = function (options) {\n  var rightChild = this.createSimilar(options);\n  rightChild.parent = this;\n  this.right = rightChild;\n\n  return rightChild;\n};\n\n\n/**\n * Insert a new element\n */\nBinarySearchTree.prototype.insert = function (key, value) {\n  // Empty tree, insert as root\n  if (!this.hasOwnProperty('key')) {\n    this.key = key;\n    this.data.push(value);\n    return;\n  }\n\n  // Same key as root\n  if (this.compareKeys(this.key, key) === 0) {\n    if (this.unique) {\n      var err = new Error(\"Can't insert key \" + key + \", it violates the unique constraint\");\n      err.key = key;\n      err.errorType = 'uniqueViolated';\n      throw err;\n    } else {\n      this.data.push(value);\n    }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    // Insert in left subtree\n    if (this.left) {\n      this.left.insert(key, value);\n    } else {\n      this.createLeftChild({ key: key, value: value });\n    }\n  } else {\n    // Insert in right subtree\n    if (this.right) {\n      this.right.insert(key, value);\n    } else {\n      this.createRightChild({ key: key, value: value });\n    }\n  }\n};\n\n\n/**\n * Search for all data corresponding to a key\n */\nBinarySearchTree.prototype.search = function (key) {\n  if (!this.hasOwnProperty('key')) { return []; }\n\n  if (this.compareKeys(this.key, key) === 0) { return this.data; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) {\n      return this.left.search(key);\n    } else {\n      return [];\n    }\n  } else {\n    if (this.right) {\n      return this.right.search(key);\n    } else {\n      return [];\n    }\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches a lower bound\n */\nBinarySearchTree.prototype.getLowerBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$gt') && !query.hasOwnProperty('$gte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$gt') && query.hasOwnProperty('$gte')) {\n    if (self.compareKeys(query.$gte, query.$gt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n\n    if (self.compareKeys(query.$gte, query.$gt) > 0) {\n      return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$gt')) {\n    return function (key) { return self.compareKeys(key, query.$gt) > 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$gte) >= 0; };\n  }\n};\n\n\n/**\n * Return a function that tells whether a given key matches an upper bound\n */\nBinarySearchTree.prototype.getUpperBoundMatcher = function (query) {\n  var self = this;\n\n  // No lower bound\n  if (!query.hasOwnProperty('$lt') && !query.hasOwnProperty('$lte')) {\n    return function () { return true; };\n  }\n\n  if (query.hasOwnProperty('$lt') && query.hasOwnProperty('$lte')) {\n    if (self.compareKeys(query.$lte, query.$lt) === 0) {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n\n    if (self.compareKeys(query.$lte, query.$lt) < 0) {\n      return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n    } else {\n      return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n    }\n  }\n\n  if (query.hasOwnProperty('$lt')) {\n    return function (key) { return self.compareKeys(key, query.$lt) < 0; };\n  } else {\n    return function (key) { return self.compareKeys(key, query.$lte) <= 0; };\n  }\n};\n\n\n// Append all elements in toAppend to array\nfunction append (array, toAppend) {\n  var i;\n\n  for (i = 0; i < toAppend.length; i += 1) {\n    array.push(toAppend[i]);\n  }\n}\n\n\n/**\n * Get all data for a key between bounds\n * Return it in key order\n * @param {Object} query Mongo-style query where keys are $lt, $lte, $gt or $gte (other keys are not considered)\n * @param {Functions} lbm/ubm matching functions calculated at the first recursive step\n */\nBinarySearchTree.prototype.betweenBounds = function (query, lbm, ubm) {\n  var res = [];\n\n  if (!this.hasOwnProperty('key')) { return []; }   // Empty tree\n\n  lbm = lbm || this.getLowerBoundMatcher(query);\n  ubm = ubm || this.getUpperBoundMatcher(query);\n\n  if (lbm(this.key) && this.left) { append(res, this.left.betweenBounds(query, lbm, ubm)); }\n  if (lbm(this.key) && ubm(this.key)) { append(res, this.data); }\n  if (ubm(this.key) && this.right) { append(res, this.right.betweenBounds(query, lbm, ubm)); }\n\n  return res;\n};\n\n\n/**\n * Delete the current node if it is a leaf\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfLeaf = function () {\n  if (this.left || this.right) { return false; }\n\n  // The leaf is itself a root\n  if (!this.parent) {\n    delete this.key;\n    this.data = [];\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = null;\n  } else {\n    this.parent.right = null;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete the current node if it has only one child\n * Return true if it was deleted\n */\nBinarySearchTree.prototype.deleteIfOnlyOneChild = function () {\n  var child;\n\n  if (this.left && !this.right) { child = this.left; }\n  if (!this.left && this.right) { child = this.right; }\n  if (!child) { return false; }\n\n  // Root\n  if (!this.parent) {\n    this.key = child.key;\n    this.data = child.data;\n\n    this.left = null;\n    if (child.left) {\n      this.left = child.left;\n      child.left.parent = this;\n    }\n\n    this.right = null;\n    if (child.right) {\n      this.right = child.right;\n      child.right.parent = this;\n    }\n\n    return true;\n  }\n\n  if (this.parent.left === this) {\n    this.parent.left = child;\n    child.parent = this.parent;\n  } else {\n    this.parent.right = child;\n    child.parent = this.parent;\n  }\n\n  return true;\n};\n\n\n/**\n * Delete a key or just a value\n * @param {Key} key\n * @param {Value} value Optional. If not set, the whole key is deleted. If set, only this value is deleted\n */\nBinarySearchTree.prototype.delete = function (key, value) {\n  var newData = [], replaceWith\n    , self = this\n    ;\n\n  if (!this.hasOwnProperty('key')) { return; }\n\n  if (this.compareKeys(key, this.key) < 0) {\n    if (this.left) { this.left.delete(key, value); }\n    return;\n  }\n\n  if (this.compareKeys(key, this.key) > 0) {\n    if (this.right) { this.right.delete(key, value); }\n    return;\n  }\n\n  if (!this.compareKeys(key, this.key) === 0) { return; }\n\n  // Delete only a value\n  if (this.data.length > 1 && value !== undefined) {\n    this.data.forEach(function (d) {\n      if (!self.checkValueEquality(d, value)) { newData.push(d); }\n    });\n    self.data = newData;\n    return;\n  }\n\n  // Delete the whole node\n  if (this.deleteIfLeaf()) {\n    return;\n  }\n  if (this.deleteIfOnlyOneChild()) {\n    return;\n  }\n\n  // We are in the case where the node to delete has two children\n  if (Math.random() >= 0.5) {   // Randomize replacement to avoid unbalancing the tree too much\n    // Use the in-order predecessor\n    replaceWith = this.left.getMaxKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.left = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.right = replaceWith.left;\n      if (replaceWith.left) { replaceWith.left.parent = replaceWith.parent; }\n    }\n  } else {\n    // Use the in-order successor\n    replaceWith = this.right.getMinKeyDescendant();\n\n    this.key = replaceWith.key;\n    this.data = replaceWith.data;\n\n    if (this === replaceWith.parent) {   // Special case\n      this.right = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    } else {\n      replaceWith.parent.left = replaceWith.right;\n      if (replaceWith.right) { replaceWith.right.parent = replaceWith.parent; }\n    }\n  }\n};\n\n\n/**\n * Execute a function on every node of the tree, in key order\n * @param {Function} fn Signature: node. Most useful will probably be node.key and node.data\n */\nBinarySearchTree.prototype.executeOnEveryNode = function (fn) {\n  if (this.left) { this.left.executeOnEveryNode(fn); }\n  fn(this);\n  if (this.right) { this.right.executeOnEveryNode(fn); }\n};\n\n\n/**\n * Pretty print a tree\n * @param {Boolean} printData To print the nodes' data along with the key\n */\nBinarySearchTree.prototype.prettyPrint = function (printData, spacing) {\n  spacing = spacing || \"\";\n\n  console.log(spacing + \"* \" + this.key);\n  if (printData) { console.log(spacing + \"* \" + this.data); }\n\n  if (!this.left && !this.right) { return; }\n\n  if (this.left) {\n    this.left.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n  if (this.right) {\n    this.right.prettyPrint(printData, spacing + \"  \");\n  } else {\n    console.log(spacing + \"  *\");\n  }\n};\n\n\n\n\n// Interface\nmodule.exports = BinarySearchTree;\n"]},"metadata":{},"sourceType":"script"}