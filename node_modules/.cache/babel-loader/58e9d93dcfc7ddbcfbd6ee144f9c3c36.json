{"ast":null,"code":"/**\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n */\nfunction randomBytes(size) {\n  var bytes = new Array(size);\n  var r;\n\n  for (var i = 0, r; i < size; i++) {\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n\n  return bytes;\n}\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n */\n\n\nfunction byteArrayToBase64(uint8) {\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n      extraBytes = uint8.length % 3 // if we have 1 byte left, pad 2 bytes\n  ,\n      output = \"\",\n      temp,\n      length,\n      i;\n\n  function tripletToBase64(num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  }\n\n  ; // go through the array every three bytes, we'll deal with trailing stuff later\n\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];\n    output += tripletToBase64(temp);\n  } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += lookup[temp >> 2];\n      output += lookup[temp << 4 & 0x3F];\n      output += '==';\n      break;\n\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];\n      output += lookup[temp >> 10];\n      output += lookup[temp >> 4 & 0x3F];\n      output += lookup[temp << 2 & 0x3F];\n      output += '=';\n      break;\n  }\n\n  return output;\n}\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\n\n\nfunction uid(len) {\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\n}\n\nmodule.exports.uid = uid;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/nedb/browser-version/browser-specific/lib/customUtils.js"],"names":["randomBytes","size","bytes","Array","r","i","Math","random","byteArrayToBase64","uint8","lookup","extraBytes","length","output","temp","tripletToBase64","num","uid","len","ceil","max","replace","slice","module","exports"],"mappings":"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","sourcesContent":["/**\n * Specific customUtils for the browser, where we don't have access to the Crypto and Buffer modules\n */\n\n/**\n * Taken from the crypto-browserify module\n * https://github.com/dominictarr/crypto-browserify\n * NOTE: Math.random() does not guarantee \"cryptographic quality\" but we actually don't need it\n */\nfunction randomBytes (size) {\n  var bytes = new Array(size);\n  var r;\n\n  for (var i = 0, r; i < size; i++) {\n    if ((i & 0x03) == 0) r = Math.random() * 0x100000000;\n    bytes[i] = r >>> ((i & 0x03) << 3) & 0xff;\n  }\n\n  return bytes;\n}\n\n\n/**\n * Taken from the base64-js module\n * https://github.com/beatgammit/base64-js/\n */\nfunction byteArrayToBase64 (uint8) {\n  var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\n    , extraBytes = uint8.length % 3   // if we have 1 byte left, pad 2 bytes\n    , output = \"\"\n    , temp, length, i;\n\n  function tripletToBase64 (num) {\n    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n  };\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n    temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2]);\n    output += tripletToBase64(temp);\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  switch (extraBytes) {\n    case 1:\n      temp = uint8[uint8.length - 1];\n      output += lookup[temp >> 2];\n      output += lookup[(temp << 4) & 0x3F];\n      output += '==';\n      break;\n    case 2:\n      temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1]);\n      output += lookup[temp >> 10];\n      output += lookup[(temp >> 4) & 0x3F];\n      output += lookup[(temp << 2) & 0x3F];\n      output += '=';\n      break;\n  }\n\n  return output;\n}\n\n\n/**\n * Return a random alphanumerical string of length len\n * There is a very small probability (less than 1/1,000,000) for the length to be less than len\n * (il the base64 conversion yields too many pluses and slashes) but\n * that's not an issue here\n * The probability of a collision is extremely small (need 3*10^12 documents to have one chance in a million of a collision)\n * See http://en.wikipedia.org/wiki/Birthday_problem\n */\nfunction uid (len) {\n  return byteArrayToBase64(randomBytes(Math.ceil(Math.max(8, len * 2)))).replace(/[+\\/]/g, '').slice(0, len);\n}\n\n\n\nmodule.exports.uid = uid;\n"]},"metadata":{},"sourceType":"script"}