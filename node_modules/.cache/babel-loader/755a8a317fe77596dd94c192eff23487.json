{"ast":null,"code":"/**\n * Responsible for sequentially executing actions on the database\n */\nvar async = require('async');\n\nfunction Executor() {\n  this.buffer = [];\n  this.ready = false; // This queue will execute all commands, one-by-one in order\n\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = []; // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n\n    for (var i = 0; i < task.arguments.length; i += 1) {\n      newArguments.push(task.arguments[i]);\n    }\n\n    var lastArg = task.arguments[task.arguments.length - 1]; // Always tell the queue task is complete. Execute callback if any was given.\n\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n          setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () {\n        cb();\n      };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () {\n        cb();\n      });\n    }\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\n\n\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\n\n\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n\n  for (i = 0; i < this.buffer.length; i += 1) {\n    this.queue.push(this.buffer[i]);\n  }\n\n  this.buffer = [];\n}; // Interface\n\n\nmodule.exports = Executor;","map":{"version":3,"sources":["C:/Users/luani/OneDrive/Área de Trabalho/Desafio MM/node_modules/nedb/lib/executor.js"],"names":["async","require","Executor","buffer","ready","queue","task","cb","newArguments","i","arguments","length","push","lastArg","setImmediate","process","nextTick","apply","fn","this","prototype","forceQueuing","processBuffer","module","exports"],"mappings":"AAAA;AACA;AACA;AAEA,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAD,CAAnB;;AAGA,SAASC,QAAT,GAAqB;AACnB,OAAKC,MAAL,GAAc,EAAd;AACA,OAAKC,KAAL,GAAa,KAAb,CAFmB,CAInB;;AACA,OAAKC,KAAL,GAAaL,KAAK,CAACK,KAAN,CAAY,UAAUC,IAAV,EAAgBC,EAAhB,EAAoB;AAC3C,QAAIC,YAAY,GAAG,EAAnB,CAD2C,CAG3C;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGH,IAAI,CAACI,SAAL,CAAeC,MAAnC,EAA2CF,CAAC,IAAI,CAAhD,EAAmD;AAAED,MAAAA,YAAY,CAACI,IAAb,CAAkBN,IAAI,CAACI,SAAL,CAAeD,CAAf,CAAlB;AAAuC;;AAC5F,QAAII,OAAO,GAAGP,IAAI,CAACI,SAAL,CAAeJ,IAAI,CAACI,SAAL,CAAeC,MAAf,GAAwB,CAAvC,CAAd,CAL2C,CAO3C;;AACA,QAAI,OAAOE,OAAP,KAAmB,UAAvB,EAAmC;AACjC;AACAL,MAAAA,YAAY,CAACA,YAAY,CAACG,MAAb,GAAsB,CAAvB,CAAZ,GAAwC,YAAY;AAClD,YAAI,OAAOG,YAAP,KAAwB,UAA5B,EAAwC;AACrCA,UAAAA,YAAY,CAACP,EAAD,CAAZ;AACF,SAFD,MAEO;AACLQ,UAAAA,OAAO,CAACC,QAAR,CAAiBT,EAAjB;AACD;;AACDM,QAAAA,OAAO,CAACI,KAAR,CAAc,IAAd,EAAoBP,SAApB;AACD,OAPD;AAQD,KAVD,MAUO,IAAI,CAACG,OAAD,IAAYP,IAAI,CAACI,SAAL,CAAeC,MAAf,KAA0B,CAA1C,EAA6C;AAClD;AACAH,MAAAA,YAAY,CAACA,YAAY,CAACG,MAAb,GAAsB,CAAvB,CAAZ,GAAwC,YAAY;AAAEJ,QAAAA,EAAE;AAAK,OAA7D;AACD,KAHM,MAGA;AACL;AACAC,MAAAA,YAAY,CAACI,IAAb,CAAkB,YAAY;AAAEL,QAAAA,EAAE;AAAK,OAAvC;AACD;;AAGDD,IAAAA,IAAI,CAACY,EAAL,CAAQD,KAAR,CAAcX,IAAI,CAACa,IAAnB,EAAyBX,YAAzB;AACD,GA5BY,EA4BV,CA5BU,CAAb;AA6BD;AAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,QAAQ,CAACkB,SAAT,CAAmBR,IAAnB,GAA0B,UAAUN,IAAV,EAAgBe,YAAhB,EAA8B;AACtD,MAAI,KAAKjB,KAAL,IAAciB,YAAlB,EAAgC;AAC9B,SAAKhB,KAAL,CAAWO,IAAX,CAAgBN,IAAhB;AACD,GAFD,MAEO;AACL,SAAKH,MAAL,CAAYS,IAAZ,CAAiBN,IAAjB;AACD;AACF,CAND;AASA;AACA;AACA;AACA;;;AACAJ,QAAQ,CAACkB,SAAT,CAAmBE,aAAnB,GAAmC,YAAY;AAC7C,MAAIb,CAAJ;AACA,OAAKL,KAAL,GAAa,IAAb;;AACA,OAAKK,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAG,KAAKN,MAAL,CAAYQ,MAA5B,EAAoCF,CAAC,IAAI,CAAzC,EAA4C;AAAE,SAAKJ,KAAL,CAAWO,IAAX,CAAgB,KAAKT,MAAL,CAAYM,CAAZ,CAAhB;AAAkC;;AAChF,OAAKN,MAAL,GAAc,EAAd;AACD,CALD,C,CASA;;;AACAoB,MAAM,CAACC,OAAP,GAAiBtB,QAAjB","sourcesContent":["/**\n * Responsible for sequentially executing actions on the database\n */\n\nvar async = require('async')\n  ;\n\nfunction Executor () {\n  this.buffer = [];\n  this.ready = false;\n\n  // This queue will execute all commands, one-by-one in order\n  this.queue = async.queue(function (task, cb) {\n    var newArguments = [];\n\n    // task.arguments is an array-like object on which adding a new field doesn't work, so we transform it into a real array\n    for (var i = 0; i < task.arguments.length; i += 1) { newArguments.push(task.arguments[i]); }\n    var lastArg = task.arguments[task.arguments.length - 1];\n\n    // Always tell the queue task is complete. Execute callback if any was given.\n    if (typeof lastArg === 'function') {\n      // Callback was supplied\n      newArguments[newArguments.length - 1] = function () {\n        if (typeof setImmediate === 'function') {\n           setImmediate(cb);\n        } else {\n          process.nextTick(cb);\n        }\n        lastArg.apply(null, arguments);\n      };\n    } else if (!lastArg && task.arguments.length !== 0) {\n      // false/undefined/null supplied as callbback\n      newArguments[newArguments.length - 1] = function () { cb(); };\n    } else {\n      // Nothing supplied as callback\n      newArguments.push(function () { cb(); });\n    }\n\n\n    task.fn.apply(task.this, newArguments);\n  }, 1);\n}\n\n\n/**\n * If executor is ready, queue task (and process it immediately if executor was idle)\n * If not, buffer task for later processing\n * @param {Object} task\n *                 task.this - Object to use as this\n *                 task.fn - Function to execute\n *                 task.arguments - Array of arguments, IMPORTANT: only the last argument may be a function (the callback)\n *                                                                 and the last argument cannot be false/undefined/null\n * @param {Boolean} forceQueuing Optional (defaults to false) force executor to queue task even if it is not ready\n */\nExecutor.prototype.push = function (task, forceQueuing) {\n  if (this.ready || forceQueuing) {\n    this.queue.push(task);\n  } else {\n    this.buffer.push(task);\n  }\n};\n\n\n/**\n * Queue all tasks in buffer (in the same order they came in)\n * Automatically sets executor as ready\n */\nExecutor.prototype.processBuffer = function () {\n  var i;\n  this.ready = true;\n  for (i = 0; i < this.buffer.length; i += 1) { this.queue.push(this.buffer[i]); }\n  this.buffer = [];\n};\n\n\n\n// Interface\nmodule.exports = Executor;\n"]},"metadata":{},"sourceType":"script"}